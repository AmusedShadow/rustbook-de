<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="Einführung.html"><strong>1.</strong> Einführung</a></li><li><a href="book/Erste_Schritte.html"><strong>2.</strong> Erste Schritte</a></li><li><ul class="section"><li><a href="book/Rust_Installieren.html"><strong>2.1.</strong> Rust installieren</a></li><li><a href="book/Hallo_Welt.html"><strong>2.2.</strong> Hallo Welt</a></li><li><a href="book/Hallo_Cargo.html"><strong>2.3.</strong> Hallo Cargo</a></li></ul></li><li><a href="book/Lerne_Rust.html"><strong>3.</strong> Lerne Rust</a></li><li><ul class="section"><li><a href="book/Ratespiel.html"><strong>3.1.</strong> Ratespiel</a></li><li><a href="book/Speisende_Philosophen.html"><strong>3.2.</strong> Speisende Philosophen</a></li><li><a href="book/Rust_In_Anderen_Sprachen.html"><strong>3.3.</strong> Rust in anderen Sprachen</a></li></ul></li><li><a href="book/Effektives_Rust.html"><strong>4.</strong> Effektives Rust</a></li><li><ul class="section"><li><a href="book/Der_Stack_Und_Der_Heap.html"><strong>4.1.</strong> Der Stack und der Heap</a></li><li><a href="book/Testen.html"><strong>4.2.</strong> Testen</a></li><li><a href="book/Bedingte_Kompilierung.html"><strong>4.3.</strong> Bedingte Kompilierung</a></li><li><a href="book/Dokumentation.html"><strong>4.4.</strong> Dokumentation</a></li><li><a href="book/Iteratoren.html"><strong>4.5.</strong> Iteratoren</a></li><li><a href="book/Nebenläufigkeit.html"><strong>4.6.</strong> Nebenläufigkeit</a></li><li><a href="book/Fehlerbehandlung.html"><strong>4.7.</strong> Fehlerbehandlung</a></li><li><a href="book/Garantien_Wählen.html"><strong>4.8.</strong> Garantien Wählen</a></li><li><a href="book/FFI.html"><strong>4.9.</strong> FFI</a></li><li><a href="book/Borrow_Und_AsRef.html"><strong>4.10.</strong> Borrow und AsRef</a></li><li><a href="book/Release_Kanäle.html"><strong>4.11.</strong> Release Kanäle</a></li></ul></li><li><a href="book/Syntax_Und_Semantik.html"><strong>5.</strong> Syntax und Semantik</a></li><li><ul class="section"><li><a href="book/Variablenbindung.html"><strong>5.1.</strong> Variablenbindung</a></li><li><a href="book/Funktionen.html"><strong>5.2.</strong> Funktionen</a></li><li><a href="book/Primitive_Typen.html"><strong>5.3.</strong> Primitive Typen</a></li><li><a href="book/Kommentare.html"><strong>5.4.</strong> Kommentare</a></li><li><a href="book/If.html"><strong>5.5.</strong> if</a></li><li><a href="book/Schleifen.html"><strong>5.6.</strong> Schleifen</a></li><li><a href="book/Besitz.html"><strong>5.7.</strong> Besitz</a></li><li><a href="book/Referenzen_Und_Ausleihen.html"><strong>5.8.</strong> Referenzen und Ausleihen</a></li><li><a href="book/Lebzeiten.html"><strong>5.9.</strong> Lebzeiten</a></li><li><a href="book/Veränderbarkeit.html"><strong>5.10.</strong> Veränderbarkeit</a></li><li><a href="book/Structs.html"><strong>5.11.</strong> Structs</a></li><li><a href="book/Enums.html"><strong>5.12.</strong> Enums</a></li><li><a href="book/Match.html"><strong>5.13.</strong> Match</a></li><li><a href="book/Muster.html"><strong>5.14.</strong> Muster</a></li><li><a href="book/Methodensyntax.html"><strong>5.15.</strong> Methodensyntax</a></li><li><a href="book/Vektoren.html"><strong>5.16.</strong> Vektoren</a></li><li><a href="book/Strings.html"><strong>5.17.</strong> Strings</a></li><li><a href="book/Generics.html"><strong>5.18.</strong> Generics</a></li><li><a href="book/Traits.html"><strong>5.19.</strong> Traits</a></li><li><a href="book/Drop.html"><strong>5.20.</strong> Drop</a></li><li><a href="book/If_Let.html"><strong>5.21.</strong> if let</a></li><li><a href="book/Trait_Objekte.html"><strong>5.22.</strong> Trait Objekte</a></li><li><a href="book/Closures.html"><strong>5.23.</strong> Closures</a></li><li><a href="book/UFCS.html"><strong>5.24.</strong> Universal Function Call Syntax</a></li><li><a href="book/Crates_Und_Module.html"><strong>5.25.</strong> Crates und Module</a></li><li><a href="book/Const_Und_Static.html"><strong>5.26.</strong> `const` und `static`</a></li><li><a href="book/Attribute.html"><strong>5.27.</strong> Attribute</a></li><li><a href="book/Type_Aliase.html"><strong>5.28.</strong> `type` Aliase</a></li><li><a href="book/Zwischen_Typen_Umwandeln.html"><strong>5.29.</strong> Zwischen typen umwandeln</a></li><li><a href="book/Assoziierte_Typen.html"><strong>5.30.</strong> Assoziierte Typen</a></li><li><a href="book/Größenlose_Typen.html"><strong>5.31.</strong> Größenlose Typen</a></li><li><a href="book/Operatoren_Und_Überladen.html"><strong>5.32.</strong> Operatoren und Überladen</a></li><li><a href="book/Deref_Umwandlung.html"><strong>5.33.</strong> Deref Umwandlung</a></li><li><a href="book/Makros.html"><strong>5.34.</strong> Makros</a></li><li><a href="book/Raw_Zeiger.html"><strong>5.35.</strong> Raw Zeiger</a></li><li><a href="book/Unsafe.html"><strong>5.36.</strong> `unsafe`</a></li></ul></li><li><a href="book/Nightly_Rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="book/Compiler_Plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="book/Inline_Assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="book/No_Stdlib.html"><strong>6.3.</strong> `no_stdlib`</a></li><li><a href="book/Intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="book/Lang_Items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="book/Fortgeschrittenes_Linken.html"><strong>6.6.</strong> Fortgeschrittenes Linken</a></li><li><a href="book/Benchmark_Tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="book/Box_Syntax_Und_Muster.html"><strong>6.8.</strong> Box Syntax und Muster</a></li><li><a href="book/Slice_Muster.html"><strong>6.9.</strong> Slice Muster</a></li><li><a href="book/Assoziierte_Konstanten.html"><strong>6.10.</strong> Assoziierte Konstanten</a></li></ul></li><li><a href="book/Glossar.html"><strong>7.</strong> Glossar</a></li><li><a href="book/Akademische_Forschung.html"><strong>8.</strong> Akademische Forschung</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Die Programmiersprache Rust</h1>
<p>Willkommen! Dieses Buch wird dir die <a href="https://www.rust-lang.org">Programmiersprache Rust</a> beibrigen.
Rust ist eine Systemprogrammiersprache mit dem Fokus auf drei Ziele:
Sicherheit, Geschwindigkeit und Nebenläufigkeit (Safety, Speed, Concurrency).
Sie hält diese Ziele ohne Garbage Collector aufrecht,
was sie zu einer nützlichen Sprache für eine Reihe von Anwendungsfällen macht
in denen andere Sprachen nicht so gut sind: Einbettung in anderen Sprachen,
Programme mit besonderen Anforderungen an Platz oder Zeit und low-level code schreiben,
wie zum Beispiel Gerätetreiber und Betriebssysteme.
Sie übertrifft derzeitige Sprachen, die auf diesen Bereich abzielen, indem sie
eine Reihe von Checks zur Kompilierzeit durchführt – ohne Kosten zur Laufzeit –,
währenddessen sie alle <em>data races</em> vermeidet.
Rust zielt auch darauf ab &quot;kostenfreihe Abstraktionen&quot; zu realisieren obwohl
einige dieser Abstraktionen sich anfühlen wie die einer Hochsprache.
Selbst dann erlaubt Rust eine genaue Kontrolle wie es eine low-level
Sprache würde.</p>
<p>“Die Programmiersprache Rust” ist in acht Abschnitte unterteilt.
Diese Einführung ist der Erste. Danach folgen:</p>
<ul>
<li><a href="book/Erste_Schritte.md">Erste Schritte</a> - Richte deinen Computer für die Entwicklung mit Rust ein.</li>
<li><a href="book/Lerne_Rust.md">Lerne Rust</a> - Lerne Rust Programmierung durch kleine Projekte.</li>
<li><a href="book/Effektives_Rust.md">Effektives Rust</a> - Fortgeschrittene Konzepte um ausgezeichneten Rust Code zu schreiben.</li>
<li><a href="book/Syntax_Und_Semantik.md">Syntax und Semantik</a> - Jedes Stück Rust auf kleine Stücke heruntergebrochen.</li>
<li><a href="book/Nightly_Rust.md">Nightly Rust</a> - <em>Cutting-edge features</em> die noch nicht im stabilen Compiler verfügbar sind.</li>
<li><a href="book/Glossar.md">Glossar</a> - Erklärungen von Begriffen die in diesem Buch verwendet werden.</li>
<li><a href="book/Bibliografie.md">Akademische Forschung</a> - Literatur die Rust beeinflusst hat.</li>
</ul>
<p>Nach dem Lesen dieser Einführung möchtest du wahrscheinlich, je nach Vorliebe,
entweder ‘<a href="book/Lerne_Rust.md">Lerne Rust</a>’ oder ‘<a href="book/Syntax_Und_Semantik.md">Syntax and Semantics</a>’ lesen:
‘<a href="book/Lerne_Rust.md">Lerne Rust</a>’ wenn du mit einem Projekt anfangen möchtest,
oder ‘<a href="book/Syntax_Und_Semantik.md">Syntax and Semantics</a>’ wenn du lieber klein anfangen und jeweils ein
einziges Konzept ausführlich lernen möchtest bevor du mit dem Nächsten weiter machst.
Reichliche Querverweise verbinden diese beiden Teile miteinander.</p>
<h3>Mithelfen</h3>
<p>Dieses Buch ist eine Community-Übersetzung von dem offiziellen Buch “The Rust Programming Language”.</p>
<p>Die Quelldateien dieser Übersetzung befinden sich auf Github:
<a href="https://github.com/panicbit/rustbook-de">github.com/panicbit/rustbook-de</a></p>
<p>Die Quelldateien des englischen Originals befinden sich ebenfalls auf Github:
<a href="https://github.com/rust-lang/rust/tree/master/src/doc/trpl">github.com/rust-lang/rust/tree/master/src/doc/trpl</a></p>
<h2>Eine kurze Einführung in Rust</h2>
<p>Ist Rust eine Sprache in der du interessiert sein könntest? Lass uns ein paar
Code Beispiele anschauen um ein Paar ihrer Stärken zu demonstrieren.</p>
<p>Das Hauptkonzept, welches Rust einmalig macht, wird
‘<em>ownership</em>’ [engl.: Eigentum] genannt. Betrachte dieses kleine Beispiel:</p>
<pre><code class="language-rust">fn main() {
    let mut x = vec![&quot;Hallo&quot;, &quot;Welt&quot;];
}
</code></pre>
<p>Dieses Programm macht eine <a href="book/Variablenbindung.md">Variablenbindung</a> namens <code>x</code>. Der Wert dieser
Bindung ist ein <code>Vec&lt;T&gt;</code>, ein ‘Vektor’, den wir durch ein <a href="book/Makros.md">Makro</a>
aus der Standardbibliothek erzeugt haben. Dieses Makro heißt <code>vec</code> und wir rufen
Makros mit einem <code>!</code> auf. Dies folgt einem allgemeinem Prinzip von Rust:
Mache Dinge klar. Makros können bedeutend mehr komplizierte Dinge tun als
Funktionsaufrufe und damit sind sie optisch eindeutig. Das <code>!</code> hilft auch beim
Parsen, was es erleichtert Werkzeuge zu schreiben und ebenfalls wichtig ist.</p>
<p>Wir haben <code>mut</code> benutzt um <code>x</code> <em>mutable</em> [engl.: veränderbar] zu machen:
Bindungen sind standardmäßig <em>immutable</em> [engl.: unveränderbar].
Wir werden den Vektor noch später in diesem Beispiel verändern.</p>
<p>Es ist ebenfalls beachtenswert, dass hier keine Typangaben notwendig waren:
Obwohl Rust statisch typisiert ist mussten wir den Typ nicht ausdrücklich
angeben. Rust hat <em>type inference</em> [engl.: Typinferenz, Typableitung] um
die Stärke statischer Typen und der Ausführlichkeit des Angeben von Typen
auszubalancieren.</p>
<p>Rust alloziert Daten bevorzugt auf dem Stack als auf dem Heap: <code>x</code> wird direkt
auf dem Stack platziert. Der <code>Vec&lt;T&gt;</code> Typ jedoch reserviert Speicher für die
Elemente des Vektors auf dem Heap. Falls du nicht mit dieser Unterscheidung
vertraut bist, dann kannst du sie fürs erste ignorieren oder einen Blick in
<a href="book/Der_Stack_Und_Der_Heap.md">‘Der Stack und der Heap’</a> werfen. Als eine Systemprogrammiersprache
gibt Rust dir die Möglichkeit zu bestimmen wie dein Speicher alloziert wird,
aber wenn du gerade erst beginnst ist das keine so große Sache.</p>
<p>Zuvor haben wir erwähnt, dass ‘ownership’ das entscheidende neue Konzept in Rust ist.
Im Rust Jargon sagen wir, dass <code>x</code> den Vektor ‘besitzt’. Dies bedeutet, dass,
wenn <code>x</code> den Scope [engl.: Geltungsbereich] verlässt, der Speicher des Vektors
freigegeben wird. Dieser Vorgang wird deterministisch vom Rust Compiler
vorgenommen, anstatt durch einen Mechanismus wie einen Garbage Collector.
Das bedeutet, dass man in Rust selber keine Funktionen wie <code>malloc</code> und
<code>free</code> aufruft: Der Compiler bestimmt statisch wann du Speicher allozieren oder
freigeben musst und fügt diese Aufrufe selber ein. Irren ist Menschlich, aber
Compiler vergessen nie.</p>
<p>Lass uns eine weitere Zeile unserem Beispiel hinzufügen:</p>
<pre><code class="language-rust">fn main() {
    let mut x = vec![&quot;Hallo&quot;, &quot;Welt&quot;];

    let y = &amp;x[0];
}
</code></pre>
<p>Wir haben eine weitere Variablenbindung <code>y</code> hinzugefügt. In diesem Fall ist
<code>y</code> eine ‘Referenz’ auf das erste Element des Vektors. Rusts Referenzen sind
ähnlich wie Zeiger in anderen Sprachen, aber mit zusätzlichen Überprüfungen zur
Kompilierzeit. Referenzen interagieren mit dem <em>ownership</em> System durch das
<a href="book/Referenzen_Und_Ausleihen.md">‘Ausleihen’</a> (borrowing) dessen worauf sie zeigen.
Der Unterschied ist, dass, wenn die Referenz den Scope verlässt,
sie nicht den zugrunde liegenden Speicher freigibt. Falls sie das täte,
dann würden wir zweimal freigeben, was schlecht ist!</p>
<p>Lass uns eine dritte Zeile hinzufügen. Sie schaut harmlos aus, erzeugt aber
einen Kompilierfehler.</p>
<pre><code class="language-rust">fn main() {
    let mut x = vec![&quot;Hallo&quot;, &quot;Welt&quot;];

    let y = &amp;x[0];

    x.push(&quot;foo&quot;);
}
</code></pre>
<p><code>push</code> ist eine Methode auf Vektoren, welche ein weiteres Element an das Ende
des Vektors anhängt. Wenn wir versuchen dieses Programm zu kompilieren, erhalten
wir einen Fehler:</p>
<pre><code class="language-text">error: cannot borrow `x` as mutable because it is also borrowed as immutable
    x.push(&quot;foo&quot;);
    ^
note: previous borrow of `x` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `x` until the borrow ends
    let y = &amp;x[0];
             ^
note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>Uff! Der Rust compiler erzeugt manchmal recht detailierte Fehler und dies ist
ein solches mal. Wie der Fehler erklärt ist zwar unsere Variablenbindung veränderbar,
aber wir können immernoch nicht <code>push</code> aufrufen. Das ist so, weil wir bereits
eine Referenz auf ein Element des Vektors, nämlich <code>y</code>, haben. Etwas zu verändern
wärend eine weitere Referenz darauf existiert ist gefährlich, weil wir die
Referenz ungültig machen könnten. In diesem konkreten Fall könnte es sein, dass
wir beim erstellen des Vektors nur Platz für zwei Elemente reserviert haben.
Ein drittes hinzuzufügen würde dazu führen einen neuen Speicherbereich für all
diese Elemente zu allozieren, hinüber zu kopieren und den internen Zeiger auf
diesen Speicher zu setzen. Das alles funktioniert problemlos. Das Problem ist,
das <code>y</code> nicht aktualisiert werden würde und wir somit einen ‘baumelnden Zeiger’
(dangling pointer) hätten. Das ist schlecht. Jegliche Benutzung von <code>y</code> wäre ein
Fehler in diesem Fall und somit hat der Compiler diesen für uns abgefangen.</p>
<p>Wie lösen wir also dieses Problem? Es gibt zwei mögliche Lösungsansätze.
Der Erste ist eine Kopie zu machen anstatt eine Referenz zu benutzen:</p>
<pre><code class="language-rust">fn main() {
    let mut x = vec![&quot;Hallo&quot;, &quot;Welt&quot;];

    let y = x[0].clone();

    x.push(&quot;foo&quot;);
}
</code></pre>
<p>Rust hat standardmäßig <a href="Besitz#move-semantics">Move Semantics</a>, daher rufen wir die <code>clone()</code>
Methode auf, wenn wir eine Kopie von irgendwelchen Daten machen wollen.
In diesem Beispiel ist <code>y</code> nicht länger eine Referenz auf den Vektor, der in <code>x</code>
gespeichert ist, sondern eine Kopie des ersten Elements, <code>&quot;Hallo&quot;</code>. Nun, da wir
keine Referenz haben, funktioniert unser <code>push()</code> einwandfrei.</p>
<p>Wenn wir wirklich eine Referenz haben wollen, dann brauchen wir die andere
Option: Sicherstellen, dass unsere Referenzen den Scope verlassen bevor wir die
Veränderung am Vektor vornehmen. Das sieht so aus:</p>
<pre><code class="language-rust">fn main() {
    let mut x = vec![&quot;Hallo&quot;, &quot;Welt&quot;];

    {
        let y = &amp;x[0];
    }

    x.push(&quot;foo&quot;);
}
</code></pre>
<p>Wir haben einen inneren Scope mittels einem weiteren Paar geschweifter Klammern
erzeugt. <code>y</code> wird den Scope verlassen bevor wir <code>push()</code> aufrufen, und damit
ist alles in Ordnung.</p>
<p>Dieses Konzept des Besitzes ist nicht nur dazu gut hängende Zeiger zu verhindern,
sondern auch eine ganze Reihe verwandter Probleme zu lösen, wie zum Beispiel
<em>iterator invalidation</em>, Nebenläufigkeit und mehr.</p>
<h1>Erste Schritte</h1>
<p>Dieser erste Abschnitt des Buches wird dich mit Rust und seinen Werkzeugen in
Fahrt bringen. Zuerst werden wir Rust installieren. Dann kommt das klassische
‘Hallo Welt’ Programm. Zum Schluss werden wir über Cargo, dem Buildsystem und
Paketmanager von Rust, reden.</p>
<h1>Rust installieren</h1>
<p>Der erste Schritt um Rust zu nutzen ist es zu installieren. Es gibt eine Reihe
von Möglichkeiten Rust zu installieren, aber die einfachste ist das <code>rustup</code>
Skript zu verwenden. Wenn du Linux oder einen Mac verwendest, dann ist alles
was du tun musst dies:</p>
<blockquote>
<p>Hinweis: Du darfst nicht die <code>$</code>-Zeichen eintippen, sie dienen nur dazu den
Anfang eines jeden Befehls anzuzeigen. Du wirst im Internet viele Tutorials
finden, welche dieser Konvention folgen: <code>$</code> für Befehle die als normaler
Benutzer ausgeführt werden und <code>#</code> für Befehle, welche du als Administrator
ausführen solltest.</p>
</blockquote>
<pre><code class="language-bash">$ curl -sf -L https://static.rust-lang.org/rustup.sh | sh
</code></pre>
<p>Falls du um die <a href="http://curlpipesh.tumblr.com">potenzielle Unsicherheit</a> bezüglich <code>curl | sh</code>
besorgt bist, dann lies bitte weiter und schau dir unseren Disclaimer weiter
unten an. Und benutze ruhig die zwei-schritte Version der Installation und
untersuche unser Installationsskript:</p>
<pre><code class="language-bash">$ curl -f -L https://static.rust-lang.org/rustup.sh -O
$ sh rustup.sh
</code></pre>
<p>Wenn du Windows benutzt, dann lade bitte den passenden
<a href="https://www.rust-lang.org/install.html">Installer</a> herunter.</p>
<p><strong>ACHTUNG:</strong> Der Windows Installer fügt Rust standardmäßig <strong>nicht</strong> der
<code>%PATH%</code> Systemvariable hinzu. Falls dies die einzige Rust Version ist, die du
installierst, und du sie von der Eingabeaufforderung aufrufen können möchtest,
dann klicke im Installationsdialog auf &quot;Advanced&quot; und stelle sicher, dass auf
der &quot;Product Features&quot; Seite &quot;Add to PATH&quot; auf die Festplatte installiert wird.</p>
<h2>Deinstallieren</h2>
<p>Falls du dich dazu entscheidest Rust nicht mehr haben zu wollen, dann werden
wir ein bisschen traurig sein, aber das ist in Ordnung. Nicht jede
Programmiersprache ist für jeden toll. Führe einfach das uninstall Skript aus:</p>
<pre><code class="language-bash">$ sudo /usr/local/lib/rustlib/uninstall.sh
</code></pre>
<p>Falls du den Windows Installer verwendet hast, dann führe einfach die <code>.msi</code>
erneut aus und dir wird eine Option zum deinstallieren angezeigt werden.</p>
<h2>Der versprochene Disclaimer</h2>
<p>Manche leute werden, ein wenig zurecht, sehr verärgert, wenn man ihnen sagt,
dass sie <code>curl | sh</code> ausführen sollen. Im Grunde vertraut man dabei den guten
Leuten, die Rust pflegen, dass sie nicht deinen Computer hacken und böse Dinge
tun. Das ist ein guter Instinkt! Falls du einer dieser Leute bist, dann schau
dir bitte die Dokumentation auf <a href="https://github.com/rust-lang/rust#building-from-source">Rust aus den Quellen erstellen</a>
oder auf <a href="https://www.rust-lang.org/install.html">der offiziellen Binary Downloadseite</a> an.</p>
<h2>Plattformunterstützung</h2>
<p>Oh, wir sollten auch die offiziell unterstützten Plattformen erwähnen:</p>
<ul>
<li>Windows (7, 8, Server 2008 R2)</li>
<li>Linux (2.6.18 oder neuer, verschiedene Distributionen), x86 und x86-64</li>
<li>OSX 10.7 (Lion) oder neuer, x86 und x86-64</li>
</ul>
<p>Wir testen Rust ausführlich auf diesen Plattformen und ebenfalls auf ein paar
anderen, wie z.B. Android. Aber diese sind jene, die am ehesten funktionieren,
da sie besser getestet sind.</p>
<p>Zuletzt ein Kommentar über Windows. Rust sieht, seit seinem Release, Windows
als eine first class Plattform an, aber wenn wir ehrlich sind, ist das Windows
Erlebnis nicht so integriert wie das Linux/OS X Erlebnis ist. Wir arbeiten
daran! Falls etwas nicht funktioniert ist es ein Bug. Lass es uns bitte wissen,
wenn das passiert. Jeder einzelne Commit wird mit Windows getestet, genau wie
bei jeder anderen Plattform.</p>
<h2>Nach der Installation</h2>
<p>Wenn du Rust installiert hast, dann kannst du eine Shell/Eingabeaufforderung
öffnen und dies eingeben:</p>
<pre><code class="language-bash">$ rustc --version
</code></pre>
<p>Du solltest eine Versionsnummer, einen Commit Hash und ein Commit Datum sehen.
Wenn du gerade die Version 1.3.0 installiert hast, dann solltest du folgendes
sehen:</p>
<pre><code class="language-text">rustc 1.3.0 (9a92aaf19 2015-09-15)
</code></pre>
<p>Falls ja, dann hast du Rust erfolgreich installiert! Gratuliere!</p>
<p>Falls nicht, und du Windows nutzt, dann Prüfe, dass Rust in deiner <code>%PATH%</code>
Systemvariable ist. Wenn nicht, dann starte den Installer nochmal und wähle
&quot;Change&quot; auf der &quot;Change, repair, or remove installation&quot; Seite und stelle
sicher, dass &quot;Add to PATH&quot; auf die Festplatte installiert wird.</p>
<p>Dieser Installer installiert auch eine lokale Kopie der Dokumentation, sodass
du sie offline lesen kannst. Auf UNIX Systemen findet man sie in
<code>/usr/local/share/doc/rust</code>. Auf Windows ist sie in dem <code>share/doc</code> Ordner, wo
auch immer du Rust hin installiert hast.</p>
<p>Falls nicht gibt es eine Reihe von Orten wo du Hilfe bekommen kannst.
Der beste ist
<a href="irc://irc.mozilla.org/#rust">der englischsprachige #rust IRC Channel auf irc.mozilla.org</a>,
welchen du mittels <a href="https://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a> betreten kannst. Klick auf den Link und
Chattest sofort mit anderen Rustlern. Falls du dich lieber auf deutsch
unterhalten möchtest, dann kannst du auch <a href="https://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust-de">#rust-de via Mibbit betreten</a>.
Andere großartige Ressourcen beinhalten das <a href="https://users.rust-lang.org/">Benutzerforum</a> und
<a href="https://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<h1>Hallo Welt!</h1>
<p>Nun, da du Rust installiert hast, lass uns dein erstes Rust Programm schreiben.
Es ist traditionell sein erstes Programm in einer neuen Sprache den Text
&quot;Hallo Welt!&quot; auf dem Bildschirm ausgeben zu lassen. Die tolle Sache an so
einem einfachen Programm ist, dass du überprüfen kannst, dass dein Compiler
nicht einfach nur installiert ist, sondern auch ordnungsgemäß funktioniert.
Und Informationen auf dem Bildschirm auszugeben ist eine ziemlich häufige Sache.</p>
<p>Das erste, was wir tun müssen, ist eine Datei erstellen, in der wir den Code
packen. Ich mag es ein <code>projekte</code> Verzeichnis in meinem Heimverzeichnis zu
erstellen und alle meine Projekte dort aufzubewahren. Rust ist es egal wo dein
Code liegt.</p>
<p>Dies führt sogar zu einer anderen Angelegenheit, welche wir behandeln sollten:
Diese Anleitung wird annehmen, dass du grundlegendend mit der Kommandozeile
vertraut bist. Rust selbst stellt keine besonderen Anforderungen an deine
Editierwerkzeuge oder wo dein Code liegt. Falls du eine IDE der Kommandozeile
vorziehst, dann möchtest du vielleicht <a href="https://github.com/oakes/SolidOak">SolidOak</a> oder Plugins für
deine bevorzugte IDE ausprobieren. Es existieren eine Reihe von Erweiterungen
von unterschiedlicher Qualität, welche von der Community entwickelt werden.
Das Rust Team liefert auch <a href="https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md">Plugins für verschiedene Editoren</a>.
Deine IDE einzurichten sprengt den Rahmen dieses Tutorials, also schau in die
Dokumentation für dein spezielles Setup.</p>
<p>Da dies nun aus dem Raum ist, lass uns damit anfangen ein Verzeichnis in unserem
Projekte Verzeichnis anzulegen.</p>
<pre><code class="language-bash">$ mkdir ~/projekte
$ cd ~/projekte
$ mkdir hallo_welt
$ cd hallo_welt
</code></pre>
<p>Wenn Windows und nicht die Powershell benuzt, dann wird <code>~</code> wohl nicht
funktionieren. Für mehr Details, schaue in die Dokumentation für deine Shell.</p>
<p>Lass uns als nächstes eine neue Quelltextdatei anlegen. Wir werden unsere Datei
<code>main.rs</code> nennen. Rust Dateien haben immer eine <code>.rs</code> Endung. Wenn du mehr
als ein Wort in deinem Dateinamen verwendest, dann benutze einen Unterstrich:
<code>hallo_welt.rs</code> anstatt <code>hallowelt.rs</code>.</p>
<p>Nun, da wir unsere Datei offen haben, tippen wir folgendes ein:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hallo Welt!&quot;);
}
</code></pre>
<p>Speichere die Datei und tippe dann in die Kommandozeile:</p>
<pre><code class="language-bash">$ rustc main.rs
$ ./main # oder main.exe unter Windows
Hallo Welt!
</code></pre>
<p>Erfolg! Lass uns im Detail durchgehen was gerade passiert ist.</p>
<pre><code class="language-rust">fn main() {

}
</code></pre>
<p>Diese Zeilen definieren eine <em>Funktion</em> in Rust. Die <code>main</code> Funktion ist
besonders: Sie ist der Anfang eines jeden Rust Programmes. Die erste Zeile sagt
&quot;Ich deklariere eine Funktion namens <code>main</code>, welche keine Argumente entgegen
nimmt und nichts zurückgibt&quot;. Falls es Argumente gäbe, dann würden sie zwischen
den Klammern (<code>(</code> und <code>)</code>) stehen, und, weil wir nichts von dieser Funktion
zurückgeben, können wir den Rückgabetyp koomplett weglassen. Darauf gehen
wir später ein.</p>
<p>Du wirst auch feststellen, dass die Funktion von geschweiften Klammern (<code>{</code> und
<code>}</code>) umgeben ist. Rust benötigt diese um jeden Funktionskörper herum. Es gilt
als guten Stil die geöffnete Klammer in die selbe Zeile wie die
Funktionsdeklaration, mit einem Leerzeichen dazwischen, zu setzen.</p>
<p>Als nächstes kommt diese Zeile:</p>
<pre><code class="language-rust">    println!(&quot;Hallo Welt&quot;);
</code></pre>
<p>Diese Zeile macht die ganze Arbeit in unserem kleinen Programm. Es gibt eine
Zahl von Details die hier wichtig sind. Das erste ist, dass die Zeile mit
vier Leerzeichen anstatt mit Tabs eingerückt ist. Bitte stelle den Editor
deiner Wahl so ein, dass mit der Tab-Taste vier Leerzeichen eingefügt werden.
Wir bieten ein paar <a href="https://github.com/rust-lang/rust/tree/master/src/etc/CONFIGS.md">Beispieleinstellungen für verschiedene Editoren</a>
an.</p>
<p>Der Zweite Punkt ist der <code>println!()</code> Teil. Dieser ruft ein Rust
<a href="Makros.md">Makro</a> (so wird Metaprogramierung in Rust gemacht) auf. Wenn es eine
Funktion wäre, dann wüde es so aussehen: <code>println()</code>. Für unsere Zwecke
brauchen wir uns nicht um diesen Unterschied kümmern. Merk dir einfach, dass du
manchmal ein <code>!</code> sehen wirst und es bedeutet, dass du ein Makro, anstatt eine
normalen Funktion, aufrufst. Rust implementiert aus einem guten Grund
<code>println!</code> als Makro anstatt als normale Funktion, aber das ist ein
fortgeschrittenes Thema. Eine letzte Sache noch: Rusts Makros sind bedeutend
anders als C Makros, falls du die mal benutzt hast. Hab keine Angst Makros zu
benutzen. Wir werden die Details später noch behandeln, aber für den Moment
musst du uns vertrauen.</p>
<p>Weiter gehts. &quot;Hallo World&quot; ist ein ‘String’. Strings sind ein überraschend
kompliziertes Thema in einer Systemprogrammiersprache, und dies ist ein
‘statisch allokierter’ String. Falls du mehr über Allokierung lesen möchtest,
dann schau dir <a href="Der_Stack_Und_Der_Heap.md">der Stack und der Heap</a>, aber du musst es nicht
unbedingt wenn du nicht möchtest. Wir übergeben den String als Argument an
<code>println!</code>, was dann den String auf dem Bildschirm ausgibt. Leicht genug!</p>
<p>Weiterhin endet die Zeile mit einem Semikolon (<code>;</code>). Rust ist eine
<a href="Glossar.md#ausdrucksorientierte-sprache">‘Ausdrucksorientierte’ Sprache</a>, was bedeuted,
dass die meisten Dinge Ausdrücke anstatt Anweisungen sind. Das <code>;</code> wird
benutzt um anzuzeigen, dass der Ausdruck zuende ist und der nächste beginnen
kann. Die meisten Zeilen in Rust Code enden mit einem <code>;</code>.</p>
<p>Und zum Schluss natürlich kompilieren wir unser Programm und lassen es laufen.
Wir können mit unserem Compiler <code>rustc</code> kompilieren, indem wir den Namen
unserer Quelltextdatei angeben:</p>
<pre><code class="language-bash">$ rustc main.rs
</code></pre>
<p>Dies ist ähnlich wie bei <code>gcc</code> oder <code>clang</code>, falls du einen C oder C++
Hintegrund hast. Rust wird binäre ausführbare Datei ausgeben.
Du kannst sie mittels <code>ls</code> sehen:</p>
<pre><code class="language-bash">$ ls
main  main.rs
</code></pre>
<p>Oder unter Windows:</p>
<pre><code class="language-bash">$ dir
main.exe  main.rs
</code></pre>
<p>Es existieren nun zwei Dateien: Unser Quellcode mit der <code>.rs</code> Endung und eine
ausführbare Datei (<code>main.exe</code> unter Window, <code>main</code> überall sonst).</p>
<pre><code class="language-bash">$ ./main  # or main.exe on Windows
</code></pre>
<p>Dies gibt nun unseren <code>Hallo Welt!</code> text in unserer Kommandozeile aus.</p>
<p>Falls du von dynamischen Sprachen wie Ruby, Python oder JavaScript kommst, dann
bist du vielleicht nicht daran gewöhnt, dass diese zwei Schritte getrennt sind.
Rust ist eine ‘ahead-of-time compiled language’, was bedeutet, dass man ein
Programm kompilieren und dann jemand anderem geben kann ohne, dass diese
Person Rust zur Ausführung benötigt. Wenn man jemandem eine <code>.rb</code>, <code>.py</code> oder
<code>.js</code> gibt, dann benötigt dieser Jemand eine installierte
Ruby/Python/JavaScript Implementierung, aber man braucht nur einen Befehl um
zu kompilieren und auszuführen. Im Sprachendesign ist alles ein Kompromiss und
Rust hat seine Entscheidung getroffen.</p>
<p>Gratuliere! Du hast nun offiziell ein Rust Programm geschrieben. Das macht dich
nun zu einem Rust Programmier! Willkommen.</p>
<p>Als nächstes würde ich dich gerne mit einem anderen Werkzeug bekanntmachen,
nämlich mit Cargo, welches benutzt wird um realitätsnahe Programme zu
schreiben. Nur <code>rustc</code> zu benutzen ist nett für simple Sachen, aber während
dein Projekt wächst wirst du etwas haben wollen, was dir hilft alle
Möglichkeiten die dir <code>rustc</code> bietet, zu managen und es dir leicht macht
code mit anderen Leuten und Projekten zu teilen.</p>
<h1>Hallo Cargo!</h1>
<p><a href="http://doc.crates.io">Cargo</a> ist ein Werkzeug, welches Rustler benutzen um ihre Rust
Projekte zu verwalten. Cargo ist derzeit in einem pre-1.0 Zustand und ist somit
immernoch in Arbeit. Jedoch ist es bereits gut genug es für viele Rust Projekte
einzusetzen und somit wird vorausgesetzt, dass Rust Projekte Cargo von Anfang
an einsetzen.</p>
<p>Cargo verwaltet drei Sachen: Das bauen des Codes, das herunterladen der
Abhängigkeiten, welche dein Projekt benötigt und
das bauen dieser Abhängigkeiten. Zu Anfang hat dein Programm keine
Abhängigkeiten, also werden wir nur den ersten Teil an Funktionalität nutzen.
Schlussendlich werden wir mehr nutzen. Da wir Cargo von Anfang an nutzen
wird es leicht sein sie hinterher hinzuzufügen.</p>
<p>Wenn du Rust mit dem offiziellen Installer installiert haben, dann wirst du
auch Cargo haben. Wenn du allerdings Rust auf eine andere Art und Weise
installiert hast, dann möchtest du möglicherweise einen Blick in die
<a href="https://github.com/rust-lang/cargo#installing-cargo-from-nightlies">Cargo README</a> werfen um herauszufinden, wie man Cargo installiert.</p>
<h2>Nach Cargo umwandeln</h2>
<p>Lass uns unser 'Hallo Welt' nach Cargo umwandeln.</p>
<p>Um ein Projekt zu &quot;Cargoifizieren&quot; benötigen wir drei Dinge:
Erstelle eine <code>Cargo.toml</code> Konfigurationsdatei, lege die Quelltexte an den
richtigen Platz und entferne die alte ausführbare Datei (<code>main.exe</code> unter
Windows, <code>main</code> sonst wo). Lass uns den ersten Teil zuerst machen:</p>
<pre><code class="language-bash">$ mkdir src
$ mv main.rs src/main.rs
$ rm main  # oder main.exe unter Windows
</code></pre>
<p>Beachte, da wir eine ausführbare Datei erstellen, dass wir <code>main.rs</code> als
Dateiname beibehalten. Wenn wir stattdessen eine Bibliothek machen wollten,
sollten wir <code>lib.rs</code> verwenden. Diese Konvention wird von Cargo benutzt um
unsere Projekte erfolgreich zu kompilieren, aber sie kann auch außer Kraft gesetzt werden, wenn wir das wollen.</p>
<p>Cargo erwartet, dass deine Quelltexte in einem <code>src</code> Verzeichnis liegen.
Das lässt das oberste Verzeichnis für andere Sachen, wie READMEs,
Lizenzinformationen und anderen Dingen, die nichts mit deinem
Code zu tun haben, frei.</p>
<!-- A place for everything, and everything in its place. -->
<p>Als Nächstes unsere Konfigurationsdatei:</p>
<pre><code class="language-bash">$ editor Cargo.toml
</code></pre>
<p>Stelle sicher, dass der Name correct ist: Das große <code>C</code> ist notwendig!</p>
<p>Schreib das hier hinein:</p>
<pre><code class="language-toml">[package]

name = &quot;hallo_welt&quot;
version = &quot;0.0.1&quot;
authors = [ &quot;Dein Name &lt;du@example.com&gt;&quot; ]
</code></pre>
<p>Diese Datei ist im <a href="https://github.com/toml-lang/toml">TOML</a> Format. TOML ist ähnlich wie INI, aber hat ein
paar tolle extra Funktionen. Der TOML Dokumentation zufolge</p>
<blockquote>
<p>Zielt TOML darauf ab ein minimales Konfigurationsformat zu sein, welches
aufgrund seiner offensichtlichen Semantik, leicht zu lesen ist. TOML ist
dazu designt eindeutig auf eine Hashtabelle abzubilden. Toml sollte in einer
breiten Vielzahl von Sprachen leicht in Datenstrukturen zu parsen sein.</p>
</blockquote>
<p>Sobald wir diese Datei im Wurzelverzeichnis unseres Projektes haben, sind wir
auch schon bereit es zu bauen! Um das zu tun, führe dies aus:</p>
<pre><code class="language-bash">$ cargo build
   Compiling hallo_welt v0.0.1 (file:///home/deinname/projekte/hallo_welt)
$ ./target/debug/hallo_welt
Hallo Welt!
</code></pre>
<p>Bumm! Wir haben unser Projekt mit <code>cargo build</code> gebaut und es mit
<code>./target/debug/hallo_welt</code> ausgeführt. Wir können beides auch in
einem einzigen Schritt machen mittels <code>cargo run</code>:</p>
<pre><code class="language-bash">$ cargo run
     Running `target/debug/hallo_welt`
Hallo Welt!
</code></pre>
<p>Beachte, dass dieses mal das Projekt nicht neu kompiliert wurde. Cargo hat
selber herausgefunden, dass wir den Quelltext nicht verändert haben, also
hat es einfach nur die Binärdatei ausgeführt. Hätten wor eine Veränderung
vorgenommen, dann hätten wir beides gesehen:</p>
<pre><code class="language-bash">$ cargo run
   Compiling hallo_welt v0.0.1 (file:///home/deinname/projekte/hallo_welt)
     Running `target/debug/hallo_welt`
Hallo Welt!
</code></pre>
<p>Dies hat uns nicht viel mehr eingebracht als einfach nur <code>rustc</code> zu benutzen,
aber denk an Zukunft: Wenn unser Projekt komplexer wird, dann müssen wir
mehr machen um alle Teile zusammen ordentlich zum kompilieren zu bringen.
Mit Cargo können wir, während unser Projekt wächst, einfach <code>cargo build</code>
aufrufen und unser Projekt wird sofort auf die richtige Art und Weise gebaut.</p>
<p>Wenn unser Projekt dann endlich fertig zum Release ist, kannst du einfach
<code>cargo build --release</code> benutzen um dein Projekt mit Optimierungen zu
kompilieren.</p>
<p>Do wirst auch feststellen,
dass Cargo eine neue Datei erzeugt hat: <code>Cargo.lock</code>.</p>
<pre><code class="language-toml">[root]
name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
</code></pre>
<p>Die <code>Cargo.lock</code> Datei wird von Cargo benutzt um deine Abhängigkeit zu
verfolgen. Im Moment haben wir keine keine, also ist sie etwas dürftig.
Du wirst diese Datei niemals selber anfassen müssen, lass einfach Cargo
die Sache regeln.</p>
<p>Das wars! Wir haben <code>hallo_welt</code> erfolgreich mit Cargo gebaut. Obwohl das
Programm simpel ist, benutzt es viele der Werkzeuge die du für den Rest
deiner Rust Karriere brauchst. <!-- klingt etwas merkwürdig -->
Du kannst erwarten, dass du mit nahezu allen Rust Projekten so
loslegen kannst:</p>
<pre><code class="language-bash">$ git clone someurl.com/foo
$ cd foo
$ cargo build
</code></pre>
<h2>Ein neues Projekt</h2>
<p>Du brauchst nicht jedes mal durch alle diese Schritte gehen, wenn du ein neues
Projekt anfängst! Cargo hat die Fähigkeit ein Gerüst-Projekt zu erzeugen, mit
dem du sofort anfangen kannst zu entwickeln.</p>
<p>Um eine neues Projekt mit Cargo anzufangen, benutze <code>cargo new</code>:</p>
<pre><code class="language-bash">$ cargo new hallo_welt --bin
</code></pre>
<p>Wir übergeben <code>--bin</code>, da es unser Ziel ist eine ausführbare Anwendung,
anstatt einer Bibliothek, zu erzeugen. Ausführbare Dateien werden oft
‘binaries’ genannt.
(So wie in <code>/usr/bin</code>, falls du auf einem Unix System bist).</p>
<p>Lass uns mal sehen wlche Dateien Cargo für uns erzeugt hat:</p>
<pre><code class="language-bash">$ cd hallo_welt
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>
<p>Falls du den <code>tree</code> Befehl nicht hast, dann kannst du ihn dir wahrscheinlich
mithilfe der Paketverwaltung deiner Distribution besogen. Der Befehl ist nicht
notwendig, aber sicherlich nützlich.</p>
<p>Das ist alles was wir brauchen um loszulegen.
Lass uns zuerst die <code>Cargo.toml</code> betrachten.</p>
<pre><code class="language-toml">[package]

name = &quot;hallo_welt&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Dein Name &lt;du@example.com&gt;&quot;]
</code></pre>
<p>Cargo hat diese Datei mit angemessenen Vorgaben, basierend auf den von dir
übergebenen Argumenten und deiner globalen <code>git</code> Konfiguration, gefüllt.
Du wirst vielleicht bemerken, dass Cargo das <code>hallo_welt</code> Verzeichnis auch
als <code>git</code> Repositorium initialisiert hat.</p>
<p>Das hier steht in der <code>src/main.rs</code>:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>Cargo hat ein &quot;Hallo Welt!&quot; für und erzeugt und du kannst sofort mit dem Coden
loslegen!
Cargo hat seinen eigenen <a href="http://doc.crates.io/guide.html">Guide</a>, welcher die Features von Cargo in
größerem Detail behandelt.</p>
<p>Nun, da du mit den Werkzeugen vertraut bist, lass uns tatsächlich mehr über
die Sprache Rust selbst lernen. Dies sind die Grundlagen, welche dir den Rest
deiner Zeit mit Rust sehr dienlich sein werden.</p>
<p>Du hast Zwei Möglichkeiten:
Entweder stürzt du dich in ein Projekt mit ‘<a href="Lerne_Rust.md">Lerne Rust</a>’,
oder du arbeitest dir deinen Weg von unten nach oben mit
‘<a href="Syntax_Und_Semantik.md">Syntax und Semantik</a>’.
Erfahrenere Systemprogrammierer werden ‘Lerne Rust’ vorziehen, wärend Leute
mit Hintergrund in dynamischen Sprachen beides vevorzugen könnten.
Verschiedene Leute lernen verschieden! Wähle was dir am besten liegt.</p>
<h1>Lerne Rust</h1>
<p>Willkommen! Dieser Abschnitt enthält ein paar Tutorials, welche dir Rust, durch
aufbauen eines Projektes, beibringen. Du wirst zuerst eine umfassende Übersicht
bekommen, aber Details werden wir überfliegen.</p>
<p>Falls du lieber eine ‘von Grund auf’-artige Erfahrung magst, dann schau dir
<a href="Syntax_Und_Semantik.md">Syntax und Semantik</a> an.</p>
<h1>Ratespiel</h1>
<p>Für unser erstes Projekt wollen wir eine
klassische Anfängeraufgabe implementieren: das Ratespiel.
So funktioniert es: Unser Programm wird eine zufällige
ganze Zahl zwischen eins und hundert erzeugen.
Es wird uns dann fragen sie zu erraten.
Bei einem Rateversuch wird es uns sagen, ob wir zu niedrig oder zu hoch liegen.
Sobald wir richtig raten, wird es uns gratulieren. Klingt das gut?</p>
<h1>Anlegen</h1>
<p>Lass uns ein neues Projekt anlegen. Gehe in dein Projekteverzeichnis.
Erinnerst du dich wie wir die Verzeichnisstruktur und eine <code>Cargo.toml</code> für
<code>hallo_welt</code> anlegen mussten? Cargo hat ein Befehl dafür, welcher das für uns
erledigt. Lass uns den ausprobieren:</p>
<pre><code class="language-bash">$ cd ~/projekte
$ cargo new ratespiel --bin
$ cd ratespiel
</code></pre>
<p>Wir übergeben den Namen unseres Projektes und – da wir eine Binärdatei
anstatt eine Bibliothek erstellen – <code>--bin</code> an <code>cargo new</code>.</p>
<p>Schau dir mal die erzeugte <code>Cargo.toml</code> an:</p>
<pre><code class="language-toml">[package]

name = &quot;ratespiel&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Dein Name &lt;du@example.com&gt;&quot;]
</code></pre>
<p>Cargo holt diese Informationen aus deiner Betriebssystemumgebung. Wenn diese
nicht korrekt sind, dann korrigiere sie ruhig.</p>
<p>Schließlich generiert Cargo noch ein <code>Hallo Welt</code> für uns.
Schau dir die <code>src/main.rs</code> an:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre>
<p>Lass uns versuchen das, was uns Cargo gegeben hat, zu kompilieren:</p>
<pre><code class="language-{bash}">$ cargo build
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
</code></pre>
<p>Ausgezeichnet! Öffne nochmal deine <code>src/main.rs</code>. Wir werden unseren ganzen
Code in diese Datei schreiben.</p>
<p>Lass mich dir noch einen weiteren Cargo Befehl zeigen: <code>run</code>. <code>cargo run</code>
ist fast  wie <code>cargo build</code>, aber führt zusätzlich noch die erzeugte ausführbare
Datei aus.</p>
<pre><code class="language-bash">$ cargo run
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
     Running `target/debug/ratespiel`
Hello, world!
</code></pre>
<p>Prima! Der <code>run</code> Befehl ist sehr praktisch, wenn man sein Projekt häufig
widerholt ausprobieren möchte. Unser Spiel ist ein solches Projekt und wir
müssen jeden Schritt zügig testen können bevor wir mit dem Nächsten fortfahren.</p>
<h1>Einen Rateversuch verarbeiten</h1>
<p>Also lass uns anfangen! Das erste, was für unser Ratespiel tun müssen, ist dem
unserem Spieler zu erlauben eine Vermutung einzugeben. Schreib das hier
in deine <code>src/main.rs</code>:</p>
<pre><code class="language-rust">use std::io;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    println!(&quot;Bitte gib deine Vermutung ein.&quot;);

    let mut vermutung = String::new();

    io::stdin().read_line(&amp;mut vermutung)
        .ok()
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    println!(&quot;Deine Vermutung: {}&quot;, vermutung);
}
</code></pre>
<p>Das ist 'ne Menge! Lass es uns Stück für Stück durchgehen.</p>
<pre><code class="language-rust">use std::io;
</code></pre>
<p>Wir werden Benutzereingaben entgegennehmen und dann das Ergebnis ausgeben
können. Dazu werden wir das <code>io</code> Modul aus der Standardbibliothek. Rust
importiert standardmäßig ein paar Dinge in jedes Programm,
das <a href="https://doc.rust-lang.org/std/prelude/index.html">das ‘Prelude’</a>. Wenn etwas nicht im Prelude ist, dann musst
du es mittels <code>use</code> importieren.</p>
<pre><code class="language-rust">fn main() {
</code></pre>
<p>Wie du zuvor schon gesehen hast, ist die <code>main()</code> Funktion der Startpunkt
in deinem Programm. Die <code>fn</code> Syntax deklariert eine neue Funktion, die <code>()</code>
zeigen an, dass es keine Argumente gibt und <code>{</code> beginnt den
Körper der Funktion. Weil wir keinen Rückgabewert angegeben haben, wird
automatisch angenommn, dass dieser <code>()</code>, ein leeres <a href="Primitive_Typen.md#Tupel">Tupel</a> ist.</p>
<pre><code class="language-rust">    println!(&quot;Rate die Zahl!&quot;);

    println!(&quot;Bitte gib deine Vermutung ein.&quot;);
</code></pre>
<p>Wir haben zuvor gelernt, dass <code>println!()</code> ein <a href="Makros.md">Makro</a> ist, dass
einen <a href="Strings.md">String</a> auf dem Bildschirm ausgibt.</p>
<pre><code class="language-rust">    let mut vermutung = String::new();
</code></pre>
<p>Nun wird es interessant! In dieser kleinen Zeile ist eine Menge los.
Das erste, was man bemerken sollte, ist eine <a href="Variablenbindung.md">let Anweisung</a>,
welche verwendet wird um ‘Variablenbindungen’ zu erzeugen.
Sie nehmen diese Form an:</p>
<pre><code class="language-rust">let foo = bar;
</code></pre>
<p>Dies wird eine neue Bindung namens <code>foo</code> erzeugen
und den Wert <code>bar</code> daran binden. In vielen Sprachen wird das eine ‘Variable’
genannt, aber Rusts Variablenbindungen haben ein paar Tricks in ihren Ärmeln.</p>
<p>Zum Beispiel sind sie standardmäßig <em>immutable</em> [unveränderbar]. Deswegen
benutzt unser Beispiel <code>mut</code>: Es macht eine Bindung <em>mutable</em> [veränderbar]
anstatt <em>immutable</em>. Auf der linken Seite der Zuweisung akzeptiert <code>let</code>
nicht einfach nur einen Namen, es akzeptiert sogar ‘<a href="Muster.md">Muster</a>’.
Wir werden Muster später noch verwenden. Es ist fürs erste leicht genug
zu benutzen:</p>
<pre><code class="language-rust">let foo = 5; // immutable (unveränderbar)
let mut bar = 5; // mutable (veränderbar)
</code></pre>
<p>Oh, und <code>//</code> leitet einen Kommentar bis zum Ende der Zeile ein.
Rust ignoriert alles in <a href="Kommentare.md">Kommentaren</a>.</p>
<p>So, nun wissen wissen wir, dass <code>let mut vermutung</code> eine neue Variablenbindung
namens <code>vermutung</code> einführt, aber wir müssen noch auf die andere Seite des <code>=</code>
schauen woran sie gebunden ist: <code>String::new()</code>.</p>
<p><code>String</code> ist ein String typ, welcher von der Standardbibliothek zur Verfügung
gestellt wird. Ein [<code>String</code>]<a href="https://doc.rust-lang.org/std/string/struct.String.html">string</a> ist ein UTF-8 kodierter Text,
der wachsen kann.</p>
<p>Die <code>::new()</code> Syntax benutzt <code>::</code> weil es eine ‘assoziierte Funktion’ eines
bestimmten Typs ist. Sprich, es ist mit <code>String</code> selbst assoziiert,
anstatt mit einer Instanz von <code>String</code>. Manche Sprachen nennen das eine
‘statische Methode’.</p>
<p>Diese Funktion heißt <code>new()</code>, da sie einen neuen, leeren <code>String</code>.
Du wirst bei vielen Typen eine <code>new()</code> Funktion finden, da es ein typischer
Name ist um irgendeine Art von neuen Wert zu erzeugen.</p>
<p>Lass uns weiter machen:</p>
<pre><code class="language-rust">    io::stdin().read_line(&amp;mut vermutung)
        .ok()
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</code></pre>
<p>Das ist eine Menge mehr! Lass uns das wieder Schritt für Schritt durchgehen.
Die erste Zeile besteht aus zwei Teilen. Hier ist der erste:</p>
<pre><code class="language-rust">io::stdin()
</code></pre>
<p>Erinnerst du dich wie wir <code>use</code> in der ersten Zeile des Programmes benutzt
haben um <code>std::io</code> zu importieren? Wir rufen nun eine Assozierte Funktion davon
auf. Wenn wir <code>use std::io</code> nicht verwendet hätten, dann hätten wir diese
Zeile als als <code>std::io::stdin()</code> schreiben können.</p>
<p>Diese spezielle Funktion gibt uns ein Handle für die Standardeingabe deines
Terminals. Genauer gesagt ein <a href="https://doc.rust-lang.org/std/io/struct.Stdin.html">std::io::Stdin</a>.</p>
<p>Der nächste Teil wird dieses Handle verwenden um an die Eingaben des Benutzers
zu gelangen:</p>
<pre><code class="language-rust">.read_line(&amp;mut vermutung)
</code></pre>
<p>Here rufen wir die [<code>read_line()</code>]<a href="https://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line">read_line</a> Methode unseres Handle auf.
<a href="Methodensyntax.md">Methoden</a> sind wie assoziierte Funktionen, aber sind nur für eine
jeweilige Instanz eines Types verfügbar, anstatt für den Typ selbst. Wir
übergeben außerdem ein Argument an <code>read_line()</code>: <code>&amp;mut vermutung</code>.</p>
<p>Erinnerst du dich wir oben <code>vermutung</code> gebunden haben? Wir hatten gesagt, dass
es <em>mutable</em> ist. Jedoch nimmt <code>read_line</code> keinen <code>String</code> als Argument: Es
nimmt einen <code>&amp;mut String</code>. Rust hat ein Feature namens
‘<a href="Referenzen_Und_Ausleihen.md">Referenzen</a>’, welches einem erlaubt mehrere Referenzen auf ein
Stück Daten zu haben, was kopieren reduzieren kann. Referenzen sind ein
komplexes Feature, da eines von Rusts haupt Verkaufsargumenten ist wie sicher
und einfach es ist Referenzen zu benutzen. Wir müssen jedoch nicht viele dieser
Details wissen um unser Programm im Moment zu vollenden.
Fürs Erste ist alles was wir kennen müssen, dass, ähnlich wie <code>let</code>
Bindungen, Referenzen standardmäßig <em>immutable</em> sind. Daher müssen wir
<code>&amp;mut vermutung</code> schreiben anstatt <code>&amp;vermutung</code>.</p>
<p>Warum nimmt <code>read_line()</code> eine <em>mutable</em> Referenz eines String? Der Job dieser
Funktion ist es die Eingaben des Benutzers auf der Standardeingabe zu nehmen
und in einem String zu platzieren. Also nimmt sie einen String als
Argument, und um die Eingabe hinzuzufügen muss dieser <em>mutable</em> sein.</p>
<p>Aber wir sind noch nicht ganz fertig mit dieser Zeile Code.
Während es sich um eine einzelne Textzeile handelt, ist es nur der erste
Teil einer einzelnen logischen Zeile an Code:</p>
<pre><code class="language-rust">        .ok()
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);
</code></pre>
<p>Wenn man eine Methode mit der <code>.foo()</code> Syntax aufruft, dann darf man eine
neue Zeile oder andere Leerzeichen einführen.
Dies hilft einem lange Zeilen aufzuteilen. Wir <em>hätten</em> auch das tun können:</p>
<pre><code class="language-rust">    io::stdin().read_line(&amp;mut vermutung).ok().expect(&quot;Fehler beim Lesen der Zeile&quot;);
</code></pre>
<p>Aber das ist schwerer zu lesen. Also haben wir es aufgeteilt in drei Zeilen für
drei Methodenaufrufe. Wir haben bereits über <code>read_line()</code> geredet,
aber was ist mit <code>ok()</code> und <code>expect()</code>? Nun, wir haben bereits erwähnt,
dass <code>read_line()</code> das, was der Benutzer eingibt, in den <code>&amp;mut String</code> steckt,
den wir ihr übergeben. Aber sie gibt auch einen Wert zurück:
In diesem Fall ein [<code>io::Result</code>]<a href="https://doc.rust-lang.org/std/io/type.Result.html">ioresult</a>. Rust hat eine Reihe von Typen
namens <code>Result</code> in seiner Standardbibliothek:
Einen allgemeines [<code>Result</code>]<a href="https://doc.rust-lang.org/std/result/enum.Result.html">result</a> und spezifische Versionen für
unter-bibliotheken, wie z.B. <code>io::Result</code>.</p>
<p>Der Zweck dieser <code>Result</code> Typen ist Informationen zur Fehlerbehandung bereit
zu stellen. Werte des <code>Result</code> Typ besitzen, wie jeder Typ, Methoden.
In diesem Fall hat <code>io::Result</code> eine <code>ok()</code> Methode, welche sagt
&quot;wir möchten annehmen, dass dieser Wert ein erfolgreicher ist&quot;. Falls nicht,
schmeißen wir einfach die Fehlerinformation weg. Warum sie wegwerfen? Nun,
für ein einfaches Programm wollen wir einfach einen allgemeinen Fehler
ausgeben, da im Grunde jeder Fehler bedeutet, dass wir nicht
fortfahren können. Die <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.ok"><code>ok()</code> Methode</a> gibt einen Wert zurück, welcher
eine weitere Methode besitzt: <code>expect()</code>. Die <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>expect()</code> Methode</a>
nimmt einen Wert auf dem sie aufgerufen wird und, falls dieser kein
erfolgreicher ist, wird eine [<code>panic</code>]<a href="Fehlerbehandlung.md">panic</a> mit der Nachricht, die man
Übergeben hat, erzeugt. Eine <code>panic</code> wie diese sorgt dafür, dass unser Programm
abstürzt und die Nachricht anzeigt.</p>
<p>Falls wir diese beiden Methodenaufrufe weglassen wird unser Programm zwar
kompilieren, aber wir werden eine Warnung bekommen:</p>
<pre><code class="language-bash">$ cargo build
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&amp;mut vermutung);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Rust warnt uns, dass wir den <code>Result</code> Wert nicht verwendet haben.
Diese Warnung stammt von einer speziellen Anmerkung, die <code>io::Result</code> hat.
Rust versucht dir zu sagen, dass du einen möglichen Fehler nicht behandelt
hast. Der richtige Weg um den Fehler zu unterdrücken ist eigentlich
Fehlerbehandlung zu schreiben. Glücklicherweise können wir diese zwei kleinen
Methoden verwenden, falls uns ein Crash in Ordnung ist, wenn es einen Fehler
gibt. Falls wir uns von dem Fehler irgendwie erholen können, dann würden
wir etwas anderes machen, aber das bewahren wir uns für ein zukünftiges
Projekt auf.</p>
<p>Es gibt nurnoch eine übrige Zeile dieses ersten Beispiels:</p>
<pre><code class="language-rust">    println!(&quot;Deine Vermutung: {}&quot;, vermutung);
</code></pre>
<p>Dies gibt den, in dem wir unsere Eingabe gespeichert haben, aus.
Die <code>{}</code> sind Platzhalter, und somit übergeben wir <code>vermutung</code> daran.
Hätten wir mehrere <code>{}</code>, dann würde wir mehrere Argumente übergeben:</p>
<pre><code class="language-rust">let x = 5;
let y = 10;

println!(&quot;x und y: {} und {}&quot;, x, y);
</code></pre>
<p>Einfach.</p>
<p>Jedenfalls war das die Tour.  Mit <code>cargo run</code> können wir ausführen,
was wir bereits haben:</p>
<pre><code class="language-bash">$ cargo run
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
     Running `target/debug/ratespiel`
Rate die Zahl!
Bitte gib deine Vermutung ein.
6
Deine Vermutung:  6
</code></pre>
<p>Also gut! Unser erster Teil ist fertig: Wir können Eingaben von der Tastatur
holen und sie wieder ausgeben.</p>
<h1>Eine geheime Zahl erzeugen</h1>
<p>Als nächstes müssen wir eine zufällige Zahl erzeugen. Rust hat noch keine
Möglichkeit um Zufallszahlen zu erzeugen in seiner Standardbibliothek.
Das Rust Team hat jedoch eine <a href="https://crates.io/crates/rand"><code>rand</code> Crate</a> zur Verfügung gestellt.
Eine ‘Crate’ [engl.: Kiste] ist ein Paket aus Rust Code.
Wir haben bereits eine ‘binary crate’ gebaut,
was eine ausführbare Datei ist.
<code>rand</code> ist eine ‘library crate’, welche den Code enthält,
der dazu Gedacht ist von anderen Programmen als Bibliothek verwendet zu
werden.</p>
<p>Cargo ist wirklich gut darin externe Crates zu verwenden. Bevor wir Code
schreiben können der <code>rand</code> verwendet, müssen wir unsere <code>Cargo.toml</code>
anpassen. Öffne sie und füge diese paar Zeilen am Ende an:</p>
<pre><code class="language-toml">[dependencies]

rand=&quot;0.3.0&quot;
</code></pre>
<p>Der <code>[dependencies]</code> Abschnitt der <code>Cargo.toml</code> ist wie der <code>[package]</code>
Abschnitt: Alles was diesem folgt gehört dazu, bis ein nächster Abschnitt
beginnt. Cargo benutzt den <em>dependencies</em> Abschnitt um zu wissen, welche
Abhängigkeiten an externen Crates du hast und welche Version du benötigst.
In diesem Fall haben wir Version <code>0.3.0</code> spezifiziert, was Cargo als ein
Release versteht, der mit dieser spezifischen Version kompatibel ist.
Cargo versteht <a href="http://semver.org">Semantische Versionierung</a>, was ein Standard ist
um Versionsnummern zu schreiben. Falls wir nur exakt <code>0.3.0</code> verwenden wollten,
dann könnten wir <code>=0.3.0</code> schreiben. Falls wir die neueste Version verwenden
wollten, dann könnten wir <code>*</code> verwenden; wir könnten eine Bereich von
Versionen verwenden. <a href="http://doc.crates.io/crates-io.html">Cargos Dokumentation</a> enthält mehr Details.</p>
<p>Nun lass uns, ohne unseren Code zu ändern, das Projekt neu kompilieren:</p>
<pre><code class="language-bash">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.8
 Downloading libc v0.1.6
   Compiling libc v0.1.6
   Compiling rand v0.3.8
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
</code></pre>
<p>(Du könntest natürlich andere Versionen sehen.)</p>
<p>Das ist eine Menge an neuer Ausgabe! Nun da wir eine externe Abhängigkeit
haben holt Cargo die aktuellste Version von allem aus der Registry, was
eine Kopie der Daten auf <a href="https://crates.io">Crates.io</a> ist. Crates.io ist der Ort,
wo Leute im Rust Ökosystem ihre Open-Source Projekte veröffentlichen
um sie für andere zur Verfügung zu stellen.</p>
<p>Nach dem aktualisieren der Registry prüft Cargo unsere <code>[dependencies]</code> und
lädt alle, die wir noch nicht haben, herunter. In diesem Fall laden wir uns
auch eine Kopie der <code>libc</code> Crate, obwohl wir gesagt haben, dass wir nur von
der <code>rand</code> Crate abhängen wollen. Das ist so weil <code>rand</code> von <code>libc</code> abhängt
um zu funktionieren. Nach dem herunterladen kompiliert Cargo diese und danach
unser Projekt.</p>
<p>Falls wir <code>cargo build</code> nochmal ausführen,
dann werden wir eine andere Ausgabe bekommen:</p>
<pre><code class="language-bash">$ cargo build
</code></pre>
<p>Genau, keine Ausgabe! Cargo weis, dass unser Projekt schon kompiliert wurde
und, dass alle unsere Abhängigkeiten kompiliert sind, also gibt es keinen
Grund diesen ganzen Kram zu machen. Da es nichts zu tun gibt, beendet es sich
einfach. Falls wir die <code>src/main.rs</code> nochmal öffnen und eine trviale Änderung
vornehmen und speichern, dann werden wir nur eine Zeile sehen:</p>
<pre><code class="language-bash">$ cargo build
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
</code></pre>
<p>So, wir haben Cargo gesagt, dass wir irgendeine <code>0.3.x</code> Version von <code>rand</code>
wollen, also hat es die aktuellste Version
(zur der Zeit als dies hier verfasst wurde) <code>v0.3.8</code> heruntergeladen.
Aber was passiert, wenn nächste Woche Version <code>v0.3.9</code> mit einem wichtigen
Bugfix herauskommt? Während Bugfixes zwar wichtig sind, was ist wenn <code>0.3.9</code>
Regressionen enthält, die das kompilieren mit unserem Code verhindern?</p>
<p>Die Antwort auf dieses Problem ist die <code>Cargo.lock</code> Datei, die du nun in
deinem Projektvrzeichniss finden wirst. Wenn du ein Projekt das erste mal
kompilierst, dann findet Cargo die ganzen Versionen heraus, die deinen
Kriterien entsprechen, und schreibt sie in die <code>Cargo.toml</code>. Wenn du dein
Projekt in der Zukunft kompilierst, dann sieht Cargo, dass die <code>Cargo.lock</code>
existiert und benutzt dann nur die darin spezifizierten Versionen, anstatt
nochmal alles erneut herauszufinden. Damit hat man automatisch
reproduzierbare Builds. In anderen Worten, du bleibst solange bei Version
<code>0.3.8</code> bis wir ausdrücklich upgraden, das gleiche gilt für jeden mit dem
wir unseren Code teilen, dank dieser Sperrdatei.</p>
<p>Was ist nun, wenn wir <code>v0.3.9</code> <em>doch</em> nutzen wollen? Cargo hat einen anderen
Befehl, <code>update</code>, der besagt &quot;ignoriere die Sperrdatei, finde die neusten
Versionen heraus die zu meiner Spezifikation passen. Falls das funktioniert,
schreibe diese Versionen in die Sperrdatei&quot;. Aber standardmäßig wird
Cargo nur nach Versionen größer als <code>0.3.0</code> und kleiner als <code>0.4.0</code> schauen.
Falls wir weiter zu <code>0.4.x</code> wollten, dann müssten wir das direkt in die
<code>Cargo.toml</code> eintragen. Wenn wir das täten, dann würde Cargo beim nächsten
<code>cargo build</code> den Index neu laden und unsere <code>rand</code> Anforderungen neu
auswerten.</p>
<p>Es gibt noch eine Menge mehr über <a href="http://doc.crates.io">Cargo</a> und seinem
<a href="http://doc.crates.io/crates-io.html">Ökosystem</a> zu erzählen, aber für das erste ist das alles
was wir wissen müssen. Cargo macht es wirklich einfach Bibliotheken
wiederzuverwenden und deswegen neigen Rustler dazu kleinere Projekte zu
schreiben, welche aus einer Reihe von Unterpaketen zusammengebaut sind.</p>
<p>Lass uns beginnen die <code>rand</code> Crate tasächlich zu <em>benutzen</em>. Hier ist unser
nächster Schritte:</p>
<pre><code class="language-rust">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die geheime Zahl ist: {}&quot;, geheime_zahl);

    println!(&quot;Bitte gib deine Vermutung ein.&quot;);

    let mut vermutung = String::new();

    io::stdin().read_line(&amp;mut vermutung)
        .ok()
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    println!(&quot;Deine Vermutung: {}&quot;, vermutung);
}
</code></pre>
<p>Das erste was wir gemacht haben ist die erste Zeile zu ändern. Dort steht nun
<code>extern crate rand</code>. Weil wir <code>rand</code> in unseren <code>[dependencies]</code> deklariert
deklariert haben, können wir <code>extern crate</code> benutzen um Rust wissen zu lassen,
dass wir sie benutzen. Dies ist außerdem das äquivalent zu einem <code>use rand;</code>,
sodass wir alles in der <code>rand</code> Crate erreichen können, indem wir es mit
<code>rand::</code> einleiten.</p>
<p>Als nächstes fügen wir noch eine weitere <code>use</code> Zeile hinzu: <code>use rand::Rng</code>.
Wir werden gleich eine Methode verwenden, welche erfordert, dass <code>Rng</code>
im Scope ist. Die grundlegende Idee ist folgende: Methoden können auf
sogenannten <code>Traits</code> definiert werden und, damit diese Methoden funktionieren,
müssen sie im aktuellen Scope sein. Für weitere Details lies den
<a href="Traits.md">Traits</a> Abschnitt.</p>
<p>Es gibt zwei weitere Zeilen, die wir in der Mitte hinzugefügt haben:</p>
<pre><code class="language-rust">    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die geheime Zahl ist: {}&quot;, geheime_zahl);
</code></pre>
<p>Wir benutzen die <code>rand__thread_rng()</code> Funktion eine Kopie des
Zufallszahlengenerators zu erhalten, welcher dem aktuellen
<a href="Nebenl%C3%A4ufigkeit.md">Thread</a> in dem wir sind, angehört.
Weil wir oben <code>use rand::Rng</code> verwendet haben, hat dieser Generator eine
<code>gen_range()</code> Methode zur Verfügung. Diese Methode nimmt zwei Argumente und
generiert eine Zahl, die zwischen diesen beiden liegt.
Der Bereich ist einschließlich dem unteren Ende und ausschließlich dem oberen
Ende, also brauchen wir <code>1</code> und <code>101</code> um eine Zahl zwischen eins bis hundert
zu erhalten.</p>
<p>Die zweite Zeile gibt einfach die geheime Zahl aus. Das ist nützlich während
wir unser Programm entwickeln, damit wir es leicht testen können.
Aber wir werden es aus der finalen Version entfernen. Es ist wohl kaum ein
Spiel, wenn es die Antwort schon beim Start ausgibt!</p>
<p>Versuche unser neues Programm ein paar mal auszuführen:</p>
<pre><code class="language-bash">$ cargo run
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
     Running `target/debug/ratespiel`
Rate die Zahl!
Die geheime Zahl ist: 7
Bitte gib deine Vermutung ein.
4
Deine Vermutung: 4
$ cargo run
     Running `target/debug/ratespiel`
Rate die Zahl!
Die geheime Zahl ist: 83
Bitte gib deine Vermutung ein.
5
Deine Vermutung: 5
</code></pre>
<p>Super! Weiter: Lass uns die Vermutung mit der geheimen Zahl vergleichen.</p>
<h1>Vermutungen vergleichen</h1>
<p>Nun da wir unsere Benutzereingabe haben, lass uns unsere Vermutung mit der
Zufallszahl vergleichen. Hier ist unser nächster Schritt, auch wenn er
<strong>noch nicht wirklich kompiliert</strong>:</p>
<pre><code class="language-rust">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die geheime Zahl ist: {}&quot;, geheime_zahl);

    println!(&quot;Bitte gib deine Vermutung ein.&quot;);

    let mut vermutung = String::new();

    io::stdin().read_line(&amp;mut vermutung)
        .ok()
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    println!(&quot;Deine Vermutung: {}&quot;, vermutung);

    match vermutung.cmp(&amp;geheime_zahl) {
        Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
        Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Gewonnen!&quot;),
    }
}
</code></pre>
<p>Es gibt ein paar neue Sachen hier. Das erste ist ein weiteres <code>use</code>.
Wir importieren einen Typ namens <code>std::cmp::Ordering</code> in den aktuellen Scope.
Dann benutzen wir ihn ein paar Zeilen später:</p>
<pre><code class="language-rust">    match vermutung.cmp(&amp;geheime_zahl) {
        Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
        Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Gewonnen!&quot;),
    }
</code></pre>
<p>Die <code>cmp()</code> Methode kann auf allem aufgerufen werden,
was verglichen werden kann und nimmt eine Referenz auf die Sache, mit der wir
vergleichen es wollen. Es gibt den Typ <code>Ordering</code> zurück, den wir zuvor
mit <code>use</code> importiert haben. Wir benutzen eine [<code>Match</code>]<a href="Match.md">match</a> Anweisung um
festzustellen welche <code>Ordering</code> genau vorliegt. <code>Ordering</code> ist ein
[<code>Enum</code>]<a href="Enums.md">enum</a>, kurz für ‘enumeration’ [engl.: Aufzählung], was so aussieht:</p>
<pre><code class="language-rust">enum Foo {
    Bar,
    Baz,
}
</code></pre>
<p>Mit dieser Definition ist der mögliche Wert des Typs <code>Foo</code>
entweder <code>Foo::Bar</code> oder <code>Foo::Baz</code>. Wir benutzen die <code>::</code> um den Namensraum
einer jeweiligen <code>enum</code> Variante anzuzeigen.</p>
<p>Das [<code>Ordering</code>]<a href="https://doc.rust-lang.org/std/cmp/enum.Ordering.html">ordering</a> <code>enum</code> hat drei mögliche Varianten:
<code>Less</code>, <code>Equal</code> und <code>Greater</code>. Die <code>match</code> Anweisung nimmt den Wert eines Typen
und lässt dich einen ‘Zweig’ für jeden möglichen Wert erstellen. Da wir drei
Arten von <code>Ordering</code> haben, haben wir drei Zweige:</p>
<pre><code class="language-rust">    match vermutung.cmp(&amp;geheime_zahl) {
        Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
        Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Gewonnen!&quot;),
    }
</code></pre>
<p>Falls der Wert <code>Less</code> ist, geben wir <code>Zu klein!</code> aus, falls er <code>Greater</code> ist,
<code>Zu groß!</code> und ist er <code>Equal</code>, dann <code>Gewonnen!</code>. <code>match</code> ist sehr nützlich und
wird häufig in Rust verwendet.</p>
<p>Ich hatte aber erwähnt, dass dieser Code so noch nicht ganz kompiliert.
Mal probieren:</p>
<pre><code class="language-bash">$ cargo build
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
src/main.rs:28:25: 28:40 error: mismatched types:
 expected `&amp;collections::string::String`,
    found `&amp;_`
(expected struct `collections::string::String`,
    found integral variable) [E0308]
src/main.rs:28     match vermutung.cmp(&amp;geheime_zahl) {
                                       ^~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `ratespiel`.
</code></pre>
<p>Uff! Das ist ein großer Fehler. Sein Kern ist, dass wir <code>mismatched types</code>,
also nicht zusammenpassende Typen haben. Rust hat ein starkes, statisches
Typensystem. Es hat jedoch auch Typinferenz.
Als wir <code>let vermutung = String::new()</code> geschrieben haben war Rust in der Lage
abzuleiten, dass <code>vermutung</code> ein <code>String</code> sein sollte und somit mussten wir
nicht den Typ ausdrücklich aufschreiben. Und bei unserer <code>geheime_zahl</code> Variable
gibt es eine Reihe von Typen, die den Wert eins bis hundert annehmen können:
<code>i32</code>, eine 32-bit Ganzzahl, oder <code>u32</code>, eine vorzeichenlose 32-bit
Ganzzahl, oder <code>i64</code>, eine 64-bit Ganzzahl, oder andere.
Soweit war das nicht wichtig, weswegen Rust standardmäßig <code>i32</code> gewählt hat.
Jedoch weis Rust hier nicht wie es <code>vermutung</code> und die <code>geheime_zahl</code>
vergleichen soll. Sie müssen vom selben Typ sein. Letztlich wollen wir für
den Vergleich den <code>String</code>, den wir von der Eingabe lesen,
in eine richtigen Zahlentyp umwandeln. Wir können das mit drei weiteren Zeilen
erledigen. Hier ist unser neues Programm:</p>
<pre><code class="language-rust">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die geheime Zahl ist: {}&quot;, geheime_zahl);

    println!(&quot;Bitte gib deine Vermutung ein.&quot;);

    let mut vermutung = String::new();

    io::stdin().read_line(&amp;mut vermutung)
        .ok()
        .expect(&quot;Fehler beim Lesen der Zeile&quot;);

    let vermutung: u32 = vermutung.trim().parse()
        .ok()
        .expect(&quot;Bitte eine Zahl eintippen!&quot;);

    println!(&quot;Deine Vermutung: {}&quot;, vermutung);

    match vermutung.cmp(&amp;geheime_zahl) {
        Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
        Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Gewonnen!&quot;),
    }
}
</code></pre>
<p>Die drei neuen Zeilen sind:</p>
<pre><code class="language-rust">    let vermutung: u32 = vermutung.trim().parse()
        .ok()
        .expect(&quot;Bitte eine Zahl eintippen!&quot;);
</code></pre>
<p>Augenblick mal, ich dachte wir hätten bereits eine <code>vermutung</code>? Ja, haben wir,
aber Rust erlaubt uns die vorherige <code>vermutung</code> mit einer neuen zu verdecken.
Dies wird häufig in genau dieser Situationen benutzt, wo <code>vermutung</code> als
<code>String</code> beginnt, wir es es aber in ein <code>u32</code> umwandeln möchten. Verdeckung von
Variablen lässt uns den Name <code>vermutung</code> wiederverwenden, anstatt wir gezwungen
sind uns einen neuen eindeutigen Namen wie <code>vermutung_str</code> und <code>vermutung</code>,
oder ähnlich, auszudenken.</p>
<p>Wir binden <code>vermutung</code> an einen Ausdruck, der so ähnlich wie ein vorheriger
aussieht:</p>
<pre><code class="language-rust">vermutung.trim().parse()
</code></pre>
<p>Gefolgt von einem <code>ok().expect()</code> Aufruf. Hier verweist <code>vermutung</code> noch auf
die alte <code>vermutung</code>, jene, die ein String mit unserer Eingabe war. Die <code>trim()</code>
Methode auf <code>String</code>s eliminiert jegliche Form von Leerzeichen am Anfang und
am Ende unseres Strings. Das ist wichtig, da wir die Entertaste drücken mussten
um <code>read_line()</code> zufrieden zu stellen. Das bedeutet, dass, wenn wir <code>5</code>
eingeben und Enter drücken, <code>vermutung</code> so aussieht: <code>5\n</code>. Das <code>\n</code> stellt
eine neue Zeile dar (erzeugt durch die Entertaste). <code>trim()</code> entfernt das und
in unserem String bleibt nur die <code>5</code> übrig.
Die <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code> Methode auf Strings</a> parst unseren String in einen
Zahlentyp. Da es verschiedene mögliche Zahlentypen gibt, müssen wir Rust einen
Hinweis geben welchen Zahlentyp wir denn genau haben wollen.
Deswegen <code>let vermutung: u32</code>.
Der Doppelpunkt (<code>:</code>) nach <code>vermutung</code> sagt Rust,
dass wir dessen Typ anmerken wollen.
<code>u32</code> ist eine vorzeichenlose 32-bit Ganzzahl.
Rust hat <a href="Primitive_Typen#numerische-typen">eine Reihe eingebauter Zahlentypen</a>,
aber wir haben <code>u32</code> gewählt.
Es ist eine gute Standardwahl für eine kleine positive Zahl.</p>
<p>Genauso wie <code>read_line()</code>, kann unser Aufruf von <code>parse()</code> einen Fehler
verursachen. Was ist, wenn unser String <code>A❤%</code> enthielte? Es gibt keine
Möglichkeit das in eine Zahl umzuwandeln. Deswegen werden wir dasselbe
wie mit <code>read_line()</code> gemachen: Wir benutzen die <code>ok()</code> und <code>expect()</code>
Methoden um unser Programm bei einem Fehler zu crashen.</p>
<p>Lass uns unser Programm ausprobieren!</p>
<pre><code class="language-bash">$ cargo run
   Compiling ratespiel v0.1.0 (file:///home/you/projects/ratespiel)
     Running `target/ratespiel`
Rate die Zahl!
Die geheime Zahl ist: 58
Bitte gib deine Vermutung ein.
  76
Deine Vermutung: 76
Zu groß!
</code></pre>
<p>Schön! Du kannst sehen, dass ich vor meiner Vermutung sogar ein paar
Leerzeichen eingetippt hat und das Programm immernoch wusste, dass Ich
76 geraten habe. Führe das Programm ein paar mal aus und stelle sicher,
dass sowohl das Raten der korrekten Zahl, als auch das Raten einer zu
kleinen Zahl funktioniert.</p>
<p>Nun funktioniert auch schon der größte Teil des Spiels,
aber wir haben nur einen Versuch. Lass uns das durch das Hinzufügen von
Schleifen ändern!</p>
<h1>Wiederholungen mit Schleifen</h1>
<p>Das <code>loop</code> Schlüsselwort gibt uns eine Endlosschleife.
Lass uns das hinzufügen:</p>
<pre><code class="language-rust">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die geheime Zahl ist: {}&quot;, geheime_zahl);

    loop {
        println!(&quot;Bitte gib deine Vermutung ein.&quot;);

        let mut vermutung = String::new();

        io::stdin().read_line(&amp;mut vermutung)
            .ok()
            .expect(&quot;Fehler beim Lesen der Zeile&quot;);

        let vermutung: u32 = vermutung.trim().parse()
            .ok()
            .expect(&quot;Bitte eine Zahl eintippen!&quot;);

        println!(&quot;Deine Vermutung: {}&quot;, vermutung);

        match vermutung.cmp(&amp;geheime_zahl) {
            Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal   =&gt; println!(&quot;Gewonnen!&quot;),
        }
    }
}
</code></pre>
<p>Und probier es aus. Aber warte, haben wir nicht gerade eine
Endlosschleife hinzugefügt? Japp.
Erinnerst du dich an unsere Diskussion über <code>parse()</code>?
Wenn wir einen &quot;nicht-Zahl&quot; eingeben, dann brechen wir ab und beenden das
Programm. Beobachte:</p>
<pre><code class="language-bash">$ cargo run
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
     Running `target/ratespiel`
Rate die Zahl!
Die geheime Zahl ist: 59
Bitte gib deine Vermutung ein.
45
Deine Vermutung: 45
Zu klein!
Bitte gib deine Vermutung ein.
60
Deine Vermutung: 60
Zu groß!
Bitte gib deine Vermutung ein.
59
Deine Vermutung: 59
Du gewinnst!
Bitte gib deine Vermutung ein.
ende
thread '&lt;main&gt;' panicked at 'Bitte eine Zahl eintippen!'
</code></pre>
<p>Ha! <code>ende</code> beended sogar das Programm. Genauso wie jede andere Eingabe, die
keine Zahl ist. Nun, das ist, milde ausgedrückt, eher suboptimal.
Zuerst lass uns tatsächlich beenden, wenn man das Spiel gewinnt:</p>
<pre><code class="language-rust">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die geheime Zahl ist: {}&quot;, geheime_zahl);

    loop {
        println!(&quot;Bitte gib deine Vermutung ein.&quot;);

        let mut vermutung = String::new();

        io::stdin().read_line(&amp;mut vermutung)
            .ok()
            .expect(&quot;Fehler beim Lesen der Zeile&quot;);

        let vermutung: u32 = vermutung.trim().parse()
            .ok()
            .expect(&quot;Bitte eine Zahl eintippen!&quot;);

        println!(&quot;Deine Vermutung: {}&quot;, vermutung);

        match vermutung.cmp(&amp;geheime_zahl) {
            Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Gewonnen!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Durch das Hinzufügen der <code>break</code> Zeile nach dem <code>Gewonnen!</code> verlassen
wir die Schleife, wenn wir gewinnen. Die Schleife zu verlassen bedeutet auch
das Programm zu beenden, da sie das letzte in unserer <code>main()</code> ist.
Wir haben noch eine weitere Anpassung zu machen: Wenn jemand eine &quot;nicht-Zahl&quot;
eingibt, dann wollen wir nicht beenden, sondern es einfach ignorieren.
Das können wir so machen:</p>
<pre><code class="language-rust">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Die geheime Zahl ist: {}&quot;, geheime_zahl);

    loop {
        println!(&quot;Bitte gib deine Vermutung ein.&quot;);

        let mut vermutung = String::new();

        io::stdin().read_line(&amp;mut vermutung)
            .ok()
            .expect(&quot;Fehler beim Lesen der Zeile&quot;);

        let vermutung: u32 = match vermutung.trim().parse() {
            Ok(zahl) =&gt; zahl,
            Err(_) =&gt; continue,
        };

        println!(&quot;Deine Vermutung: {}&quot;, vermutung);

        match vermutung.cmp(&amp;geheime_zahl) {
            Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Gewonnen!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Diese Zeilen wurden geändert:</p>
<pre><code class="language-rust">let vermutung: u32 = match vermutung.trim().parse() {
    Ok(zahl) =&gt; zahl,
    Err(_) =&gt; continue,
};
</code></pre>
<p>So geht man in der Regel von &quot;stürze bei einem Fehler ab&quot; zu
&quot;behandle den Fehler tatsächlich&quot;, indem man von <code>ok().expect()</code>
zu einer <code>match</code> Anweisung wechselt. Das <code>Result</code>, welches von <code>parse()</code>
zurückgegeben wird, ist tatsächlich ein <code>enum</code>, genau wie <code>Ordering</code>,
aber in diesem Fall enthält jede Variante ein paar Daten:
<code>Ok</code> ist ein Erfolg und <code>Err</code> ist ein Fehlschlag. Jeder davon enthält
ein paar Daten:  Die erfolgreich geparste Zahl oder einen Fehlertyp.
In diesem Fall, &quot;matchen&quot; wir <code>Ok(zahl)</code>, was den inneeren Wert von <code>Ok</code>
an den Name <code>num</code> bindet und danach diesen Wert auf der rechten Seite
zurückgibt. Im <code>Err</code> Fall interessieren wir uns nicht für die Art des
Fehlers, also benutzen wir einfach <code>_</code> anstatt einen Namen.
Dies ignoriert den Fehler und <code>continue</code> sorgt dafür, dass wir mit der
nächsten Iteration der Schleife fortfahren.</p>
<p>Nun sollte alles in Ordnung sein! Mal ausprobieren:</p>
<pre><code class="language-bash">$ cargo run
   Compiling ratespiel v0.1.0 (file:///home/du/projekte/ratespiel)
     Running `target/ratespiel`
Rate die Zahl!
Die geheime Zahl ist: 61
Bitte gib deine Vermutung ein.
10
Deine Vermutung: 10
Zu klein!
Bitte gib deine Vermutung ein.
99
Deine Vermutung: 99
Zu groß!
Bitte gib deine Vermutung ein.
foo
Bitte gib deine Vermutung ein.
61
Deine Vermutung: 61
Gewonnen!
</code></pre>
<p>Wunderbar! Es fehlt noch eine winzig kleine Änderung damit das
Ratespiel fertig ist. Kannst du dir vorstellen welche?
Genau, wir wollen unsere geheime Zahl nicht ausgeben.
Die Ausgabe war gut zum Testen, aber sie nimmt dem Spiel ein wenig
den Sinn. Hier ist der fertige Code:</p>
<pre><code class="language-rust">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Rate die Zahl!&quot;);

    let geheime_zahl = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Bitte gib deine Vermutung ein.&quot;);

        let mut vermutung = String::new();

        io::stdin().read_line(&amp;mut vermutung)
            .ok()
            .expect(&quot;Fehler beim Lesen der Zeile&quot;);

        let vermutung: u32 = match vermutung.trim().parse() {
            Ok(zahl) =&gt; zahl,
            Err(_) =&gt; continue,
        };

        println!(&quot;Deine Vermutung: {}&quot;, vermutung);

        match vermutung.cmp(&amp;geheime_zahl) {
            Ordering::Less    =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Gewonnen!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<h1>Fertig!</h1>
<p>Jetzt hast du erfolgreich das Ratespiel gebaut! Gratuliere!</p>
<p>Dieses erste Projekt hat dir eine Menge gezeigt: <code>let</code>, <code>match</code>,
Methoden, assoziierte Funktionen, wie man externe Crates verwendet, und mehr.
Unser nächstes Projekt wird soger noch mehr demonstrieren.</p>
<h1>Speisende Philosophen</h1>
<h1>Rust in anderen Sprachen</h1>
<h1>Effektives Rust</h1>
<!--vim:set spelllang=de:-->
<p>Wir haben also bis jetzt einige Grundlagen in Rust erworben.
Bis zu <em>gutem Rust</em> fehlt allerdings noch ein kleines Stück.</p>
<p>Dieses Kapitel besteht aus einer Reihe relativ unabhängiger Tutorials,
welche erklären wie wir das nächste Level in Rust erreichen.
Dabei werden wir auf übliche Patterns und Features der Standardbibliothek eingehen.
Diese Unterkapitel halten keine explizite Reihenfolge ein.</p>
<h1>Der Stack und der Heap</h1>
<p>Rust operiert auf einer sehr niedrigen Ebene im System.
Wenn du bereits Erfahrung mit Programmiersprachen hast,
bei denen Speicherverwaltung automatisiert wird,
dann sind dir eventuell einige Aspekte einer Systemsprache noch nicht vertraut.
Das wichtigste ist, wie Speicher funktioniert, mit Stack und Heap.
Wenn dir Speicherallokation in C-artigen Sprachen bereits vertraut ist,
dann sieh dieses Kapitel als Auffrischung.
Wenn nicht, dann lernst du hier Grundlagen, aus der Sicht von Rust.</p>
<h2>Speicher Verwaltung</h2>
<p>Die beiden Begriffe Stack und Heap beschreiben unterschiedliche Bereiche im Arbeitsspeicher und helfen uns dabei zu unterscheiden wann Speicher alloziert und dealloziert wird.</p>
<p>Hier zum Vergleich:</p>
<p>Der Stack ist sehr schnell und daher der Ort an dem Rust standardmäßig Speicher alloziert.
Der Speicher im Stack ist allerdings nur lokal innerhalb einer Funktion verfügbar.
Der Heap, auf der anderen Seite, ist langsamer, wird explizit für von deinem Programm alloziert aber ist dafür global erreichbar und hat prinzipiell keine Größenbeschränkung.</p>
<h2>Der Stack</h2>
<p><em>(engl. stack = <strong>&quot;Der Stapel&quot;</strong> )</em></p>
<p>Nehmen wir mal ein Beispiel:</p>
<pre><code class="language-rust">fn main() {
    let x = 42;
}
</code></pre>
<p>Dieses Programm besteht nur aus einer Variablenzuweisung, <code>x</code>.
Der Speicher für <code>x</code> muss irgendwo alloziert werden.
Rust ‘Stack-Alloziert‘ standardmäßig, das heißt Werte landen auf dem Stack.
Was heißt das?</p>
<p>Wenn eine Funktion aufgerufen wird, dann wird für jede ihrer lokalen Variablen, und etwas extra Information, Speicher auf ihrem Stack, dem Stackframe,  reserviert.
Für diese Tutorial ignorieren wir die extra Informationen erstmal.
Wenn <code>main()</code> also ausgeführt wird, dann allozieren wir einen einzelnen 32-bit Integer auf dem Stackframe, das passiert hier ganz automatisch.
Wenn die Funktion terminiert wird der Stackframe freigegeben.
Auch vollautomatisch.</p>
<p>Das ist alles, für diese kleine Beispiel.
Der Kernpunkt an dieser Lektion ist, dass Stackallokation sehr sehr schnell ist,
da wir bereits vor dem Start des Programms die lokalen Variablen kennen und daher den Speicher für sie auch schon ganz am Anfang auf einmal reservieren können.
Da alle lokalen Variablen nach Ende der Funktion nicht mehr benötigt werden, können wir sie auch alle auf einmal wieder freigeben.</p>
<p>Der Nachteil hier ist jedoch, dass wir die Werte der Variablen nicht länger als für die Dauer einer einzelnen Funktion vorhalten können.
Dafür gibt es dann den Heap.</p>
<p>Doch was heißt Stack eigentlich.
Dafür hier ein etwas umfangreicheres Beispiel:</p>
<pre><code class="language-rust">fn foo() {
    let y = 5;
    let z = 100;
}

fn main() {
    let x = 42;

    foo();
}
</code></pre>
<p>Dieses Programm hat insgesamt drei Variablen: zwei in <code>foo()</code> und eine in <code>main()</code>.
Just vor dem Aufruf von <code>main()</code> wird ein Integer auf deren Stack alloziert.
Die Sicht deines Betriebssystem auf den Speicher entspricht im Prinzip einer langen Liste von Adressen, von 0 bis <code>n</code>.
Wobei <code>n</code> von der Größe des Arbeitsspeichers abhängt.
Wenn du zum Beispiel nur 1 Gigabyte RAM haben solltest, ist <code>n</code> <code>1,073,741,823</code> (2<sup>30</sup>-1).</p>
<p>Hier eine Darstellung des Stackframes:</p>
<p>| Adresse | Name | Wert  |
|---------|------|-------|
| 0       | x    | 42    |</p>
<p>Wir haben <code>x</code> auf Adresse <code>0</code>, mit dem Wert <code>42</code>.</p>
<p>Wenn nun <code>foo()</code> aufgerufen wird, wird ein weiter Stackframe alloziert:</p>
<p>Daher auch der Begriff &quot;Stack&quot; = &quot;Stapel&quot;,
es wird immer etwas oben drauf gelegt und auch ausschließlich von oben wieder herunter genommen.
Wie bei einem Stapel Teller.
Solange <code>foo()</code> läuft, ist auch <code>main()</code> noch nicht beendet und der Speicher beider Funktionen ist noch vergeben.
Der Speicher von <code>main()</code> kann noch nicht freigegeben werden bevor <code>foo()</code> noch nicht beendet ist.
Jedoch kann <code>foo()</code> auch nicht direkt auf den Speicher von <code>main()</code> zugreifen.</p>
<p>| Adresse | Name | Wert  |
|---------|------|-------|
| 2       | z    | 100   |
| 1       | y    | 5     |
| 0       | x    | 42    |</p>
<p>Da <code>0</code> bereits im erst Stackframe vergeben war, verwendet <code>foo()</code> nun Adressen <code>1</code> und <code>2</code>. Der Stapel wächst sprichwörtlich nach oben mit jedem Funktionsaufruf.</p>
<p>Die Adressen <code>0</code> bis <code>2</code> sind allerdings rein zur Illustration gewählt,
im tatsächlichen Speicher hätten diese Adressen andere werte und wären auch nicht direkt aufeinander folgend.</p>
<p>Nachdem <code>foo()</code> beendet ist wird sein frame wieder vom Stapel genommen und wird sind wieder zurück bei:</p>
<p>| Adresse | Name | Wert  |
|---------|------|-------|
| 0       | x    | 42    |</p>
<p>Und dann, nachdem <code>main()</code> ebenfalls fertig ist wird auch diese Adresse wieder freigegeben. Ganz einfach!</p>
<p>Ein drittes Beispiel:</p>
<pre><code class="language-rust">fn bar() {
    let i = 6;
}

fn foo() {
    let a = 5;
    let b = 100;
    let c = 1;

    bar();
}

fn main() {
    let x = 42;

    foo();
}
</code></pre>
<p>Als erstes <code>main()</code>:</p>
<p>| Adresse | Name | Wert  |
|---------|------|-------|
| 0       | x    | 42    |</p>
<p><code>main()</code> ruft <code>foo()</code> auf:</p>
<p>| Adresse | Name | Wert  |
|---------|------|-------|
| 3       | c    | 1     |
| 2       | b    | 100   |
| 1       | a    | 5     |
| 0       | x    | 42    |</p>
<p>Dann ruft <code>foo()</code> <code>bar()</code> auf:</p>
<p>| Adresse | Name | Wert  |
|---------|------|-------|
| 4       | i    | 6     |
| 3       | c    | 1     |
| 2       | b    | 100   |
| 1       | a    | 5     |
| 0       | x    | 42    |</p>
<p>Puh! Unser Stapel wächst in die Höhe.</p>
<p>Nach dem <code>bar()</code> fertig ist, wird sein Stackframe dealloziert und es bleiben nur der von <code>foo()</code> und <code>main()</code>:</p>
<p>| Adresse | Name | Wert  |
|---------|------|-------|
| 3       | c    | 1     |
| 2       | b    | 100   |
| 1       | a    | 5     |
| 0       | x    | 42    |</p>
<p>Und dann wird <code>foo()</code> auch noch fertig und wir haben nur noch <code>main()</code>:</p>
<p>| Adresse | Name | Wert  |
|---------|------|-------|
| 0       | x    | 42    |</p>
<p>Wir sind fertig.
Kriegst du ein Gefühl für die Tellerstapel?
Wir legen einen drauf und nehmen einen wieder runter,
wir nehmen nie was aus der Mitte raus.</p>
<h2>Der Heap</h2>
<p><em>(engl. heap = <strong>&quot;Der Haufen&quot;</strong> )</em></p>
<p>Wie bereits erwähnt können Funktionen nicht auf die lokalen variablen von anderen Funktionen Zugreifen.
Manchmal möchte man jedoch etwas von einer Funktion an eine andere übergeben oder länger als für die Laufzeit einer Funktion im Speicher behalten.
Dafür haben wir den Heap.</p>
<p>In Rust allozieren wir Speicher auf dem Heap mit einer [<code>Box&lt;T&gt;</code>]<a href="http://doc.rust-lang.org/stable/std/boxed/">box</a>.
Hier ein Beispiel:</p>
<pre><code class="language-rust">fn main() {
    let x = Box::new(5);
    let y = 42;
}
</code></pre>
<p>Was also diesmal in <code>main()</code> passiert ist folgendes:</p>
<p>| Adresse | Name | Wert   |
|---------|------|--------|
| 1       | y    | 42     |
| 0       | x    | ?????? |</p>
<p>Wir allozieren Speicher für zwei Variablen auf dem Stack, wie gehabt.
<code>y</code> ist <code>42</code>, aber was ist <code>x</code>?
Nun, <code>x</code> ist ein <code>Box&lt;i32&gt;</code>, und <code>Box</code>en allozieren ihren Speicher auf dem Heap.
Der eigentliche Wert dieser Box ist ein <code>struct</code> das eine Adresse zu einem Stück Speicher (genug für einen <code>i32</code>) auf dem Heap beinhaltet.
Wenn wir nun die Funktion ausführen und <code>Box::new()</code> aufrufen,
wird der Speicher auf dem Heap alloziert und <code>5</code> dorthin geschrieben.
Der Speicher sieht also eigentlich etwa so aus:</p>
<p>| Adresse              | Name | Wert                   |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 5                      |
| ...                  | ...  | ...                    |
| 1                    | y    | 42                     |
| 0                    | x    | → (2<sup>30</sup>) - 1 |</p>
<p>Wir haben (2<sup>30</sup>) - 1 Adressen in unserem imaginären 1GB RAM.
Da der Stack von 0 nach oben wächst ist es am einfachsten die Adressen von Oben nach unten für den Heap zu verwenden.
Der erste Wert steht also an der höchsten Stelle im Speicher.
Das <code>struct</code> auf <code>x</code> hat einen <a href="Raw_Zeiger.md">raw Zeiger</a> auf die Stelle an der wir den Speicher auf dem Heap alloziert haben,</p>
<p>also den Wert (2<sup>30</sup>) - 1.</p>
<p>Wir habe noch nicht wirklich viel darüber gesprochen, was es eigentlich bedeutet in diesen Kontexten Speicher zu allozieren und zu deallozieren.
Das zu vertiefen würde den Rahmen dieses Tutorials sprengen,
aber was wichtig ist mitzunehmen, ist dass der Heap nicht einfach nur ein von oben nach unten wachsender Stack ist.
Im Gegensatz um Stack muss der Heap nicht in einer festen Reihenfolge alloziert und freigegeben werden kann.
Dadurch kann er allerdings Löcher haben.
Dazu wird es später ein Beispiel.
Hier erst mal ein kleines Diagramm des Speicherlayouts eines Programms das schon ein Weilchen lief:</p>
<p>| Adresse              | Name | Wert                   |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 5                      |
| (2<sup>30</sup>) - 2 |      |                        |
| (2<sup>30</sup>) - 3 |      |                        |
| (2<sup>30</sup>) - 4 |      | 42                     |
| ...                  | ...  | ...                    |
| 3                    | y    | → (2<sup>30</sup>) - 4 |
| 2                    | y    | 42                     |
| 1                    | y    | 42                     |
| 0                    | x    | → (2<sup>30</sup>) - 1 |</p>
<p>In diesem Fall haben wir 4 Werte auf dem Heap alloziert, aber deallozieren zwei davon.
Es gibt eine Lücke zwischen (2<sup>30</sup>) - 1 und (2<sup>30</sup>) - 4,
die momentan nicht benutzt wird.
Die genauen Details wie und warum das passiert hängen davon ab mit welcher Strategie man seinen Heap verwaltet.
Verschiedene Programme können unterschiedliche Speicherallokatoren verwenden,
also Bibliotheken, die einem das abnehmen.
Rust Programme verwenden <a href="http://www.canonware.com/jemalloc/">jemalloc</a>.</p>
<p>Zurück zu unserem Beispiel.
Da sich diese Werte auf dem Heap befinden, können sich länger existieren als die Funktion die die Box erzeugt hat.
In diesem Fall jedoch nicht.[^1]
Wenn eine Funktion endet wird ihr Stackframe freigegeben.
<code>Box&lt;T&gt;</code> hat einen Trick: <a href="Drop.md">Drop</a>.
Es implementiert <code>Drop</code> und gibt sobald die ihr Wert auf dem Stack freigegeben wird ebenfalls den Speicher auf dem Heap frei.
Geil! Wenn also <code>x</code> verschwindet gibt es vorher seinen Speicher auf dem Heap frei:</p>
<p>| Adresse | Name | Wert   |
|---------|------|--------|
| 1       | y    | 42     |
| 0       | x    | ?????? |</p>
<p>Sobald der Stackframe verschwindet, wird der gesamte verwendete Speicher freigegeben.</p>
<h2>Argumente und Ausleihen</h2>
<p>Wir hatten bereits ein paar Grundlegende Beispiele für Stack und Heap,
aber was ist mit Funktionsargumenten und Ausleihen?</p>
<pre><code class="language-rust">fn foo(i: &amp;i32) {
    let z = 42;
}

fn main() {
    let x = 5;
    let y = &amp;x;

    foo(y);
}
</code></pre>
<p>Wenn ihr <code>main()</code> betreten sieht der Speicher so aus:</p>
<p>| Adresse | Name | Wert   |
|---------|------|--------|
| 1       | y    | → 0    |
| 0       | x    | 5      |</p>
<p><code>x</code> ist einfach wieder <code>5</code> und <code>y</code> ist eine Referenz auf <code>x</code>.
Sein Wert ist also die Speicheradresse von <code>x</code>, in diesem Fall also <code>0</code>.</p>
<p>Was passiert wenn wir nun <code>foo()</code> aufrufen und <code>y</code> übergeben?</p>
<p>| Adresse | Name | Wert   |
|---------|------|--------|
| 3       | z    | 42     |
| 2       | i    | → 0    |
| 1       | y    | → 0    |
| 0       | x    | 5      |</p>
<p>Stackframes sind nicht nur für Lokale Zuweisungen, sie sind auch für Argumente gedacht.
In diesem Fall also brauchen wir sowohl <code>i</code>, das Argument und <code>z</code>, die lokale Variable.
<code>i</code> ist die Kopie des Arguments <code>y</code>, also auch <code>0</code>.</p>
<p>Das ist der Grund dafür dass man ausgeliehenen Speicher nicht deallozieren kann. Wenn man wir nun <code>x</code> freigeben würde, würden <code>y</code> und <code>i</code> auf ungültigen Speicher zeigen.
Das ist in Sprachen wie C möglich, aber nicht in Rust.</p>
<h2>Ein komplexes Beispiel</h2>
<p>Gehen wir das hier mal Schritt für Schritt durch:</p>
<pre><code class="language-rust">fn foo(x: &amp;i32) {
    let y = 10;
    let z = &amp;y;

    baz(z);
    bar(x, z);
}

fn bar(a: &amp;i32, b: &amp;i32) {
    let c = 5;
    let d = Box::new(5);
    let e = &amp;d;

    baz(e);
}

fn baz(f: &amp;i32) {
    let g = 100;
}

fn main() {
    let h = 3;
    let i = Box::new(20);
    let j = &amp;h;

    foo(j);
}
</code></pre>
<p>Als erstes rufen wir <code>main()</code> auf:</p>
<p>| Adresse              | Name | Wert                   |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| ...                  | ...  | ...                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |</p>
<p>Wir allozieren Speicher für <code>j</code>, <code>i</code> und <code>h</code>.
<code>i</code> liegt auf dem Heap, beinhaltet also einen Adresswert dort hin.</p>
<p>Als nächstes wird am ende von <code>main()</code> <code>foo()</code> aufgerufen:</p>
<p>| Adresse              | Name | Wert                   |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| ...                  | ...  | ...                    |
| 5                    | z    | → 4                    |
| 4                    | y    | 10                     |
| 3                    | x    | → 0                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |</p>
<p>Speicher wird für <code>x</code>, <code>y</code> und <code>z</code> belegt.
Das Argument <code>x</code> hat den gleichen Wert wie <code>j</code>, da wird das ja übergeben haben, ein Zeiger auf die Adresse <code>0</code>, da <code>j</code> auf <code>h</code> zeigt.</p>
<p>Danach ruft <code>foo()</code> <code>baz()</code> auf und übergibt <code>z</code>:</p>
<p>| Adresse              | Name | Wert                   |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| ...                  | ...  | ...                    |
| 7                    | g    | 100                    |
| 6                    | f    | → 4                    |
| 5                    | z    | → 4                    |
| 4                    | y    | 10                     |
| 3                    | x    | → 0                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |</p>
<p>Wir haben Speicher für <code>f</code> und <code>g</code> alloziert.
<code>baz()</code> ist sehr kurz und wenn es vorbei ist wird sein Stackframe freigegeben:</p>
<p>| Adresse              | Name | Wert                   |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| ...                  | ...  | ...                    |
| 5                    | z    | → 4                    |
| 4                    | y    | 10                     |
| 3                    | x    | → 0                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |</p>
<p>Danach ruft <code>foo()</code> <code>bar()</code> mit <code>x</code> und <code>z</code> auf:</p>
<p>| Adresse              | Name | Wert                   |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| (2<sup>30</sup>) - 2 |      | 5                      |
| ...                  | ...  | ...                    |
| 10                   | e    | → 9                    |
| 9                    | d    | → (2<sup>30</sup>) - 2 |
| 8                    | c    | 5                      |
| 7                    | b    | → 4                    |
| 6                    | a    | → 0                    |
| 5                    | z    | → 4                    |
| 4                    | y    | 10                     |
| 3                    | x    | → 0                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |</p>
<p>Wir allozieren also einen weiteren Wert auf dem Heap und müssen eins von (2<sup>30</sup>) - 1 abziehen.
Das ist einfacher das zu schreiben als <code>1,073,741,822</code> ☺.
Jedenfalls, hier die Variablen wie gewohnt.</p>
<p>Am ende von <code>bar()</code> wird wieder <code>baz()</code> aufgerufen:</p>
<p>| Adresse              | Name | Wert                   |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| (2<sup>30</sup>) - 2 |      | 5                      |
| ...                  | ...  | ...                    |
| 12                   | g    | 100                    |
| 11                   | f    | → 9                    |
| 10                   | e    | → 9                    |
| 9                    | d    | → (2<sup>30</sup>) - 2 |
| 8                    | c    | 5                      |
| 7                    | b    | → 4                    |
| 6                    | a    | → 0                    |
| 5                    | z    | → 4                    |
| 4                    | y    | 10                     |
| 3                    | x    | → 0                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |</p>
<p>So, jetzt haben wir den tiefsten Punkt in unserer Schachtelung erreicht,
Glückwunsch, du bist bist jetzt noch dran geblieben.</p>
<p>Nachdem <code>baz()</code> nun zu ende ist können wir <code>f</code> und <code>g</code> wegwerfen:</p>
<p>| Adresse              | Name | Wert                   |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| (2<sup>30</sup>) - 2 |      | 5                      |
| ...                  | ...  | ...                    |
| 10                   | e    | → 9                    |
| 9                    | d    | → (2<sup>30</sup>) - 2 |
| 8                    | c    | 5                      |
| 7                    | b    | → 4                    |
| 6                    | a    | → 0                    |
| 5                    | z    | → 4                    |
| 4                    | y    | 10                     |
| 3                    | x    | → 0                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |</p>
<p>Danach endet <code>bar()</code>. <code>d</code> ist hier ja eine <code>Box&lt;T&gt;</code>, also geben wir noch den Speicher an der Adresse frei, auf die sie zeigt:(2<sup>30</sup>) - 2.</p>
<p>| Adresse              | Name | Wert                   |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| ...                  | ...  | ...                    |
| 5                    | z    | → 4                    |
| 4                    | y    | 10                     |
| 3                    | x    | → 0                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |</p>
<p>Dann ist <code>foo()</code> fertig:</p>
<p>| Adresse              | Name | Wert                   |
|----------------------|------|------------------------|
| (2<sup>30</sup>) - 1 |      | 20                     |
| ...                  | ...  | ...                    |
| 2                    | j    | → 0                    |
| 1                    | i    | → (2<sup>30</sup>) - 1 |
| 0                    | h    | 3                      |</p>
<p>Und endlich auch <code>main()</code>.
Hiernach wir der Rest aufgeräumt.
Sobald <code>i</code> ge<code>Drop</code>pt wird, wird auch der Rest vom Heap geleert.</p>
<h2>Was machen andere Sprachen?</h2>
<p>Viele Sprachen verwenden heutzutage einen GarbageCollector.
Das hat einige Vorteile, die Beschreibung welcher allerdings den Rahmen dieses Tutorials übersteigt.
Dort hat meinen keinen manuellen Einfluß darauf, ob Speicher auf dem Heap oder Stack verwendet wird.
Stattdessen liegt fast alles auf dem Heap und der GarbageCollector hält regelmäßig das Programm kurz an und räumt auf.</p>
<p>Bei Sprachen wie C/C++ kann man zwischen Stack und Heap unterscheiden, muss allerdings manuell seinen Speicher aufräumen.
Hier gibt es bereits moderne Mechanismen, u.a. SmartPointer, die ähnliche Charakteristika haben wie Rust <code>Box&lt;T&gt;</code> etc, Konzepte wie &quot;Besitz&quot; und &quot;Ausleihen&quot; sind allerdings noch kein Kernfeature der Sprache.</p>
<h2>Was soll ich benutzen?</h2>
<p>Der Stack ist schneller und einfacher zu handhaben, wofür also den Heal=p?
Ein wichtiger Grund ist dass Stack-allozieren alleine nur LIFO[^2] Verhalten bietet.
Heapallokation ist vielseitiger und erlaubt schnelles Übergeben von großen Werten ohne Kopieren.</p>
<p>Allgemein ist Stackallokation zu bevorzugen, weshalb Rust standardmässig den Stack, das ist grundlegend einfacher und meistens effizienter.</p>
<h2>Laufzeiteffizienz</h2>
<p>Speicher auf dem Stack verwalten ist trivial:
Die Maschine inkrementiert und dekrementiert einfach den sogenannten <em>Stack-Pointer</em>.
Speicher auf dem Heap verwalten ist nicht trivial:
Speicher auf dem Heap kann beliebig freigegeben werden und jeder Block auf dem Heap kann eine beliebige Größe haben, es ist allgemein schwerer wiederverwendbare Bereiche zu identifizieren.</p>
<p>Um hier noch tiefer einzusteigen kannst du <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.143.4688">diese Paper</a>(englisch) lesen oder Grundstudiums-&quot;Betriebssysteme&quot;-Vorlesungen der Uni deiner Wahl besuchen :D</p>
<h2>Semantische Bedeutung</h2>
<p>Stackallokation beeinflusst nicht nur Rust selbst, sondern auch das mentale Modell des Entwicklers.
LIFO-Semantik definiert Rusts automatische Speicherverwaltung.
Selbst die Freigabe von Heap-allozierten Boxen mit einem einzelnen Besitzer wird von der LIFO-Semantik des Stacks bestimmt, wie bereits oben demonstriert.
Nicht-LIFO-Semantik würde zwar mehr Flexibilität bieten,
jedoch könnte ein nicht automatisch zur Compilezeit abgeleiten werden,
wann Speicher freigegeben werden kann.
Ein Compiler müsste sich auf dynamische Protokolle, potentiell außerhalb der Sprache selbst, verlassen (zum Beispiel <em>reference counting</em> wie in <code>Rc&lt;T&gt;</code> und <code>Arc&lt;T&gt;</code>).</p>
<p>Wenn man es übertreibt kann man sagen, dass die erhöhte Freiheit durch Heapallokation mit signifikanten Kosten verbunden ist, entweder in Form von Laufzeit-Performance (z.B. durch einen GarbageCollector) oder durch erhöhten Aufwand für den Entwickler in Form von expliziten Mechanismen zur Speicherverwaltung (<code>new</code>, <code>delete</code>), welche Rust nicht vorsieht.</p>
<p>[^1]: Wir können den Speicher länger leben lassen indem wir den Besitz übertragen das heißt manchmal ‘moving out of the box’. Komplexere Beispiele folgen später.</p>
<p>[^2]: Last in first out.</p>
<h1>Testing</h1>
<blockquote>
<p>Program testing can be a very effective way to show the presence of bugs, but
it is hopelessly inadequate for showing their absence.</p>
<p>*Das Testen von Programmen ist eine sehr effektive Art,
die Anwesenheit von Bugs zu zeigen, aber ist hoffnungslos unangemessen, deren Abwesenheit zu zeigen.*</p>
<p>Edsger W. Dijkstra, &quot;The Humble Programmer&quot; (1972)</p>
</blockquote>
<h2>Das <code>test</code> Attribut</h2>
<p>In Rust ist ein Test ganz einfach eine Funktion die mit <code>test</code> annotiert ist.
Beginnen wir also ein kleines Cargo Projekt namens <code>adder</code>:</p>
<pre><code class="language-bash">$ cargo new adder
$ cd adder
</code></pre>
<p>Wenn wir <code>cargo new</code> ohne <code>--bin</code> ausführen erzeugt Cargo ein Library-Projekt.
Cargo generiert automatisch einen kleinen Test, wie man am Inhalt von <code>src/lib.rs</code> sieht:</p>
<pre><code class="language-rust">#[test]
fn it_works() {
}
</code></pre>
<p>Achte auf <code>#[test]</code>.
Das ist ein Attribut und es markiert die Funktion <code>it_works()</code> als Test.
Sie ist erst mal leer.
Dann kann sie auch auch nicht fehlschlagen.
Wir können sie ganz einfach mit <code>cargo test</code> ausführen:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Hier sehen wir zwei Ausgaben.
Die erste für den Test den wir geschrieben haben,
die zweite für Dokumentationstests, davon später mehr.
Vorerst:</p>
<pre><code class="language-text">test it_works ... ok
</code></pre>
<p>Beachte dass hier der Name unserer Funktion <code>it_works</code> steht.</p>
<pre><code class="language-rust">fn it_works() {
}
</code></pre>
<p>Warum schlägt dieser leere Test aber nun nicht fehl?
Jeder Test der kein <code>panic!()</code> provoziert ist erfolgreich.
Wie könnten wir ihn nun fehlschlagen lassen?</p>
<pre><code class="language-rust">#[test]
fn it_works() {
    assert!(false);
}
</code></pre>
<p><code>assert!</code> ist ein Macro in Rust das genau ein Argument nimmt,
und wenn das nicht <code>true</code> ist, dann ruft es <code>panic!</code> auf.
Also nochmal:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... FAILED

failures:

---- it_works stdout ----
        thread 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3



failures:
    it_works

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured

thread '&lt;main&gt;' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247
</code></pre>
<p>Rust sagt uns, dass unser Test gefailt ist.</p>
<pre><code class="language-text">test it_works ... FAILED
</code></pre>
<p>Was uns auch die Zusammenfassung am Ende sagt:</p>
<pre><code class="language-text">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Wir haben ebenfalls einen non-zero status code bekommen, ein feature unserer Shell (<em>linux und OS X</em>), dass das letzte Kommando fehlgeschlagen ist.</p>
<pre><code class="language-bash">$ echo $?
101
</code></pre>
<p>Auf Windows in <code>cmd</code> :</p>
<pre><code class="language-bash">&gt; echo %ERRORLEVEL%
</code></pre>
<p>oder PowerShell:</p>
<pre><code class="language-bash">&gt; echo $LASTEXITCODE # Der Exitcode selbst
&gt; echo $? # ein boolean, Erfolgreich oder nicht
</code></pre>
<p>Das ist nützlich wenn du <code>cargo test</code> in andere Tools integrieren willst.</p>
<p>Wir können den Test auch invertieren, wenn wir wollen, dass er fehlschlägt: <code>should_panic</code>:</p>
<pre><code class="language-rust">#[test]
#[should_panic]
fn it_works() {
    assert!(false);
}
</code></pre>
<p>Der Test zählt nun als erfolgreich, wenn <code>panic!</code> eintritt.
Gleich mal ausprobieren:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Rust kennt noch ein weiteres Macro: <code>assert_eq!</code>, zum Vergleichen zweier Werte:</p>
<pre><code class="language-rust">#[test]
#[should_panic]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}
</code></pre>
<p>Schlägt das hier nun fehl?
Nein, denn da steht noch <code>should_panic</code>:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p><code>should_panic</code> ist immer mit etwas Vorsicht zu genießen, denn es schwer sicher zu sein, ob der Test nicht auf Grund anderer Probleme ge<code>panic</code>t hat.
Wir können aber Bedingungen für bestimmte Fehler hinzufügen:</p>
<pre><code class="language-rust">#[test]
#[should_panic(expected = &quot;assertion failed&quot;)]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}
</code></pre>
<p>Jetzt muss das <code>assert_eq!</code> fehlschlagen, sonst scheitert der Test trotzdem.</p>
<p>Soviel also zu Grundlagen, schreiben wir endlich einen nützlichen Test!</p>
<pre><code class="language-rust">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[test]
fn it_works() {
    assert_eq!(4, add_two(2));
}
</code></pre>
<p>Das ist ein klassischer Fall für <code>assert_eq!</code>: Wir rufen eine Funktion auf und vergleichen ihren Rückgabewert.</p>
<h2>Das <code>ignore</code> Attribut</h2>
<p>In Manchen Situationen wollen wir bestimmte Tests nicht immer mit ausführen, besonders, wenn sie teuer sind.
Diese kann man dann mit <code>ignore</code> ausschalten:</p>
<pre><code class="language-rust">#[test]
fn it_works() {
    assert_eq!(4, add_two(2));
}

#[test]
#[ignore]
fn expensive_test() {
    // Code der eine Stunde läuft
}
</code></pre>
<p>Jetzt werden sie exklusiv dann ausgeführt wenn wir <code>cargo test -- --ignored</code> ausführen:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Wir sehen: <code>it_works</code> wurde getestet, <code>expensive_test</code> nicht.</p>
<pre><code class="language-bash">$ cargo test -- --ignored
     Running target/adder-91b3e234d4ed382a

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Wichtig: <code>--ignored</code> ist ein Argument, das von dem Testbinary interpretiert wird, nicht von Cargo selbst.
Das wird mit den extra <code>--</code> vermittelt.</p>
<h2>Das <code>tests</code> Modul</h2>
<p>Was ist allerdings, wenn wir noch Hilfsfunktionen für unsere Tests brauchen,
die selbst keine Tests sind, die wir aber auch nicht mit ausliefern wollen?
Dafür kann man Tests innerhalb eines <code>tests</code> Moduls implementieren.
So in etwa:</p>
<pre><code class="language-rust">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::add_two;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Das erlaubt es uns alle unsere Tests hier zu gruppieren und zusätzlich auch noch ggf. Hilfsfunktionen zu implementieren.
Dieses gesamte Modul wird nicht in unser crate kompiliert, wenn wir es nicht explizit als Test kompilieren, wir haben also nie Testcode in unserer Bibliothek.
Das spart nicht nur Kompilierzeit, sondern auch noch Platz.</p>
<p>Eine weitere Änderung ist die <code>use</code> Deklaration.
Weil wir uns hier in einem Untermodul und damit einem anderen Namespace befinden müssen, müssen wir die zu testende Funktion quasi importieren.
Das kann nerven, wenn wir irgendwann größere Projekte haben, also vereinfachen wir das doch einfach mit <code>*</code></p>
<pre><code class="language-rust,ignore">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Beachte, dass sich die <code>use</code> Zeile geändert hat:</p>
<pre><code class="language-bash">$ cargo test
    Updating registry `https://github.com/rust-lang/crates.io-index`
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Schön!</p>
<p>Die momentane Konvention ist, dass das <code>tests</code> Modul deine &quot;unit-style&quot; tests enthält.
Alles was nur kleine Funktionalitätstests umfasst.
Integrationstest jedoch, verdienen etwas mehr platz, dafür haben wir das <code>tests</code> Verzeichnis.</p>
<h2>Das <code>tests</code> Verzeichnis</h2>
<p>Um einen Integrationstest zu schreiben erzeugen wir erst einmal unser <code>tests</code> Verzeichnis und legen darin eine <code>.rs</code> Datei an: <code>tests/lib.rs</code>:</p>
<pre><code class="language-rust,ignore">extern crate adder;

#[test]
fn it_works() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>Das sieht unserem vorherigen Test schon sehr ähnlich, naja, nicht ganz.
Wir haben nun die Zeile <code>extern crate adder</code> ganz oben.
Das ist weil die Tests im <code>tests</code> Verzeichnis ein eigenes Crate sind und daher unsere Bibliothek erst einbinden müssen.
Das ist auch ein Grund warum Integrationstests hier gut aufgehoben sind, sie verwenden unsere Bibliothek genauso wie es ein dritter tun würde.</p>
<p>Führen wir sie aus:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Jetzt haben wir drei Sektionen: unsere vorherigen Tests werden ja immernoch ausgeführt.</p>
<p>Das ist alles zum <code>tests</code> Verzeichnis.
Das <code>tests</code> Modul brauchen wir hier nicht, da alles mit Tests zu tun hat.</p>
<p>Kommen wir nun zum dritten Teil: Dokumentation.</p>
<h2>Dokumentationstests</h2>
<p>Nichts ist besser als Dokumentation mit Beispielen.
Nichts ist blöder als wenn die Beispiele in der Dokumentation nicht funktionieren, zum Beispiel, weil sich die API verändert hat, seitdem die Dokumentation geschrieben wurde.
Rust macht damit Schluss, indem es automatisch den Code in der Dokumentation mit ausführt.
<em>Allerdings nur bei Bibliothek-Crates, nicht Binary-Crates.</em>
Hier nochmal <code>src/lib.rs</code> mit Beispielen:</p>
<pre><code class="language-rust">//! The `adder` crate provides functions that add numbers to other numbers.
//!
//! # Examples
//!
//! ```
//! assert_eq!(4, adder::add_two(2));
//! ```

/// This function adds two to its argument.
///
/// # Examples
///
/// ```
/// use adder::add_two;
///
/// assert_eq!(4, add_two(2));
/// ```
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Wichtig hier: Moduldokumentation beginnt mit <code>//!</code> und Funktionsdokumentation mit <code>///</code>.
Kommentare die mit <code>//</code> beginnen landen nicht in der Dokumentation.
Rusts Dokumentationswerkzeug unterstützt Markdown, daher markieren drei Accent grave Zeichen *(backticks &quot;`&quot;)*
Es ist Konvention eine Überschrift <code># Examples</code> <em>(bitte Englisch)</em> zu haben, dem dann die Beispiele folgen.</p>
<p>Noch ein Testlauf:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 2 tests
test add_two_0 ... ok
test _0 ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Jetzt haben wir alle drei Arten von Tests getestet.
Hier heißt der Dokumentationstest <code>_0</code> und der Funktionstest <code>add_two_0</code>.
Die Zahl wir inkrementiert je mehr Tests dazukommen.</p>
<p>Wir haben noch nicht alles wichtige zu Dokumentationstests hier erwähnt.
Für mehr schau in das <a href="documentation">Dokumentationskapitel</a>.</p>
<h1>Bedingte Kompilierung</h1>
<p>Rust hat ein spezielles Attribut, <code>#[cfg]</code>,
welches es uns erlaubt Code nur dann kompilieren zu lassen wenn ein bestimmtes Flag an den Compiler übergeben wird. Davon gibt es zwei Formen:</p>
<pre><code class="language-rust">#[cfg(foo)]
# fn foo() {}

#[cfg(bar = &quot;baz&quot;)]
# fn bar() {}
</code></pre>
<p>Dann gibt es noch Zusätze wie <code>any()</code>, <code>all()</code> oder <code>not()</code>:</p>
<pre><code class="language-rust">#[cfg(any(unix, windows))]
# fn foo() {}

#[cfg(all(unix, target_pointer_width = &quot;32&quot;))]
# fn bar() {}

#[cfg(not(foo))]
# fn not_foo() {}
</code></pre>
<p>Und diese können wiederum beliebig geschachtelt werden:</p>
<pre><code class="language-rust">#[cfg(any(not(unix), all(target_os=&quot;macos&quot;, target_arch = &quot;powerpc&quot;)))]
# fn foo() {}
</code></pre>
<p>Um diese Schalter an und auszuschalten, benutzt du in deiner <code>Cargo.toml</code> die <a href="http://doc.crates.io/manifest.html#the-%5Bfeatures%5D-section"><code>[features]</code> Sektion</a> (englisch):</p>
<pre><code class="language-toml">[features]
# no features by default
default = []

# The “secure-password” feature depends on the bcrypt package.
secure-password = [&quot;bcrypt&quot;]
</code></pre>
<p>Wenn das passiert ist übergibt Cargo die Flags auf diese Weise an <code>rustc</code>:</p>
<pre><code class="language-text">--cfg feature=&quot;${feature_name}&quot;
</code></pre>
<p>Die Summe dieser <code>cfg</code> Flags bestimmt welche aktiviert und damit kompiliert werden.
Hier am Beispiel:</p>
<pre><code class="language-rust">#[cfg(feature = &quot;foo&quot;)]
mod foo {
}
</code></pre>
<p>Wenn wir jetzt mit <code>cargo build --features &quot;foo&quot;</code> kompilieren,
wird das Flag <code>--cfg feature=&quot;foo&quot;</code> an <code>rustc</code> gesendet und das Ergebnis wird <code>mod foo</code> enthalten.
Wenn wir allerdings normal mit <code>cargo build</code> kompiliren, ohne extra Flags, gibt es kein <code>foo</code>.</p>
<h1>cfg_attr</h1>
<p>Man kann auch andere Attribute basierend auf <code>cfg</code> Variablen mit <code>cfg_attr</code> setzen:</p>
<pre><code class="language-rust">#[cfg_attr(a, b)]
# fn foo() {}
</code></pre>
<p>Das ist das selbe wie <code>#[b]</code> wenn <code>a</code> vom <code>cfg</code> Attribut gesetzt ist.
Sonst nichts.</p>
<h1>cfg!</h1>
<p>Das <code>cfg!</code> Macro ist eine <a href="Compiler_Plugins.md">Syntax Erweiterung</a> die dich diese Flags an beliebigen Stellen im Code verwenden lässt:</p>
<pre><code class="language-rust">if cfg!(target_os = &quot;macos&quot;) || cfg!(target_os = &quot;ios&quot;) {
    println!(&quot;Think Different!&quot;);
}
</code></pre>
<p>Das wird zur beim Kompilieren durch <code>true</code> oder <code>false</code> ersetzt,
je nach Konfiguration.</p>
<h1>Dokumentation</h1>
<p>Dokumentation ist ein wichtiger Teil eines jeden Software Projekts.
In Rust ist sie ein Sprachbestandteil.
Reden wir doch mal über die Tools die uns Rust zur Verfügung stellt um unser Projekt zu Dokumentieren.</p>
<h2>Über <code>rustdoc</code></h2>
<p>Das Rust Paket beinhaltet ein Tool namens <code>rustdoc</code>, welches Dokumentation generiert.
<code>rustdoc</code> wird von Cargo für <code>cargo doc</code> verwendet.</p>
<p>Dokumentation kann auf zwei arten erzeugt werden: aus dem Quelltext und aus Markdown Dateien.</p>
<h2>Dokumentation von Quelltext</h2>
<p>Die primäre Methode ein Rust Projekt zu dokumentieren ist den Quelltext zu annotieren.
Dafür gibt es eine eigene Art von Kommentaren:</p>
<pre><code class="language-rust">/// Constructs a new `Rc&lt;T&gt;`.
///
/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
pub fn new(value: T) -&gt; Rc&lt;T&gt; {
    // hier die implementation
}
</code></pre>
<p>Dieser Code generiert Dokumentation die <a href="https://doc.rust-lang.org/nightly/std/rc/struct.Rc.html#method.new">wie diese aussieht</a>.
Nur halt ohne die Implementierung.</p>
<p>Das erste was uns an diesen Annotationen auffällt ist dass es mit <code>///</code> anstatt <code>//</code> anfängt.
Drei Slashes deuten einen Dokumentationskommentar an.</p>
<p>Dokumentation wird in Markdown geschrieben.</p>
<p>Rust kann diese Kommentare unterscheiden und daraus Dokumentation erzeugen.
Das ist unter anderem wichtig wenn man Dinge wie <code>enum</code>s dokumentiert:</p>
<pre><code class="language-rust">/// The `Option` type. See [the module level documentation](index.html) for more.
enum Option&lt;T&gt; {
    /// No value
    None,
    /// Some value `T`
    Some(T),
}
</code></pre>
<p>Das hier oben funktioniert, das folgende leider nicht:</p>
<pre><code class="language-rust">/// The `Option` type. See [the module level documentation](index.html) for more.
enum Option&lt;T&gt; {
    None, /// No value
    Some(T), /// Some value `T`
}
</code></pre>
<p>Dafür gibt es sogar eine Fehlermeldung:</p>
<pre><code class="language-text">hello.rs:4:1: 4:2 error: expected ident, found `}`
hello.rs:4 }
           ^
</code></pre>
<p>Dieser <a href="https://github.com/rust-lang/rust/issues/22547">Fehler</a> ist leider richtig so denn Dokumentationskommentare beziehen sich immer auf was direkt auf sie folgt.</p>
<h3>Dokumentation Schreiben</h3>
<p>Gehen wir also mal auf die einzelnen Teile diese Dokumentation ein:</p>
<pre><code class="language-rust">/// Constructs a new `Rc&lt;T&gt;`.
</code></pre>
<p>Im Grunde gelten hier die gleichen Regeln wie für git commit Nachrichten.
Die erste Zeile der Dokumentation sollte eine kurze Zusammenfassung dessen sein, worauf sie sich bezieht. Nur ein Satz. Nur Grundsätzliches. Nicht in die Tiefe.</p>
<pre><code class="language-rust">///
/// Other details about constructing `Rc&lt;T&gt;`s, maybe describing complicated
/// semantics, maybe additional options, all kinds of stuff.
///
</code></pre>
<p>Wenn wir noch mehr aussagen möchten, können wir einen weiteren Absatz zur Beschreibung hinzufügen.</p>
<h4>Spezielle Überschriften</h4>
<p>Als nächstes ein paar spezielle Überschriften.
Diese beginnen in Markdown immer mit einem <code>#</code>.
Es gibt vier sehr gebräuchliche Überschriften, diese sind allerdings reine Konvention, sie haben keine eigene Syntax.</p>
<pre><code class="language-rust">/// # Panics
# fn foo() {}
</code></pre>
<p><code>panic</code> indiziert in Rust vornehmlich, dass ein nicht behebbarer Fehler aufgetreten ist,
meistens durch Programmierfehler.
In diesen Fällen soll der aktuelle Thread &quot;kontrolliert abstürzen&quot;.
Wenn das in deinem Programm so vorgesehen ist, solltest du in der Dokumentation explizit darauf hinweisen.</p>
<pre><code class="language-rust">/// # Failures
# fn foo() {}
</code></pre>
<p>Wenn deine Funktion/Methode ein <code>Result&lt;T, E&gt;</code> zurückgibt,
dann beschreibe die Bedingungen unter denen es einen <code>Err(E)</code> zurückgibt.
Das ist nicht ganz so wichtig wie eine Panik, da Failures Teil des Typsystems sind, aber es ist dennoch wichtig.</p>
<pre><code class="language-rust">/// # Safety
# fn foo() {}
</code></pre>
<p>Wenn die Funktion <code>unsafe</code> verwendet, dann sollte ebenfalls explizit darauf hingewiesen werden, da hier eventuell Probleme auftreten können vor denen Rust anderweitig gefeit ist.</p>
<pre><code class="language-rust">/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
</code></pre>
<p>Viertens, <code>Examples</code>.
Wenn du nur ein bis zwei Beispiele zu deiner Dokumentation hinzufügst erleichterst du anderen den Umgang mit deiner Bibliothek erheblich.
Dokumentation kann noch so detailiert sein, bevor man wissen möchte wie etwas funktioniert möchte man wissen wie man es benutzt.
Bevor du dich fragst wie das Mahlwerk deiner neue Kaffeemaschine funktioniert, interessiert dich doch eher, wie du damit Kaffee kochst oder?</p>
<pre><code class="language-rust">/// # Examples
///
/// Einfache `&amp;str` Patterns:
///
/// ```
/// let v: Vec&lt;&amp;str&gt; = &quot;Mary had a little lamb&quot;.split(' ').collect();
/// assert_eq!(v, vec![&quot;Mary&quot;, &quot;had&quot;, &quot;a&quot;, &quot;little&quot;, &quot;lamb&quot;]);
/// ```
///
/// Kompliziertere Patterns mit einem Lambda:
///
/// ```
/// let v: Vec&lt;&amp;str&gt; = &quot;abc1def2ghi&quot;.split(|c: char| c.is_numeric()).collect();
/// assert_eq!(v, vec![&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]);
/// ```
</code></pre>
<p>Reden wir einmal etwas detailierter über Codeblöcke.</p>
<h4>Codeblock Annotationen</h4>
<p>Um Quelltext in Kommentaren zu schreiben benutzt man in Markdown drei Accent Graves.</p>
<pre><code class="language-rust">/// ```
/// println!(&quot;Hello, world&quot;);
/// ```
# fn foo() {}
</code></pre>
<p>Dabei wir wird in der ersten Zeile normalerweise die Programmiersprache für den Highlighter angegeben.
Bei uns ist Rust Standard, wenn du etwas anderes angeben willst dann sieht das zum Beispiel so aus:</p>
<pre><code class="language-rust">/// ```c
/// printf(&quot;Hello, world\n&quot;);
/// ```
# fn foo() {}
</code></pre>
<p>Wenn du Plaintext ausgeben willst nimm <code>```text</code></p>
<p>Es ist wichtig die richtige Codeblockannotation zu wählen, da <code>rustdoc</code> diese nicht nur für Highlighting verwendet.
Denn die Beispiele in deinem Crate können tatsächlich getestet werden.
Somit wird sichergestellt, dass sie nicht veraltet sind.
Wenn du allerdings C Code nicht mit <code>```c</code> annotierst, denkt <code>rustdoc</code> es muss ihn als Rust kompilieren und meldet dann Fehler, weil das natürlich nicht geht.</p>
<h2>Dokumentation als Tests</h2>
<p>Reden wir einmal über unsere Beispiele:</p>
<pre><code class="language-rust">/// ```
/// println!(&quot;Hello, world&quot;);
/// ```
# fn foo() {}
</code></pre>
<p>Dir ist vielleicht aufgefallen, dass du kein <code>fn main()</code> gebraucht hast.
<code>rustdoc</code> generiert hier automatisch einen Wrapper dafür.
Zum Beispiel:</p>
<pre><code class="language-rust">/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
</code></pre>
<p>Das testet dann eigentlich diesen Code:</p>
<pre><code class="language-rust">fn main() {
    use std::rc::Rc;
    let five = Rc::new(5);
}
</code></pre>
<p>Hier ist der gesamte Algorithmus den <code>rustdoc</code> verwendet um Beispiele nachzubearbeiten:</p>
<ol>
<li>Jedes <code>#![foo]</code> Attribut am Anfang bleibt als Crate Attribut intakt.</li>
<li>Einige gebräuchliche <code>allow</code> Attribute werden eingefügt um die Linter zu beschwichtigen und die Regeln etwas weniger streng zu machen, u.a. <code>unused_variables</code>, <code>unused_assignments</code>, <code>unused_mut</code>, <code>unused_attributes</code>, und <code>dead_code</code>.</li>
<li>Wenn ein Beispiel keine <code>extern crate</code> enthält wird <code>extern crate &lt;mein crate&gt;;</code> hinzugefügt.</li>
<li>Zum Schluss wird der Code noch in ein <code>fn main() {...}</code> eingepackt, wenn das noch nicht so ist.</li>
</ol>
<h2>Partielle Beispiele</h2>
<p>Manchmal reicht die Nachbearbeitung aber nicht ganz,
zum Beispiel wenn man nur auf ganz bestimmte Zeilen hinweisen will.
Die obig genannten Beispiele mit <code>///</code> sehen eigentlich ein wenig anders aus:</p>
<pre><code class="language-text">/// Kleines Beispiel.
# fn foo() {}
</code></pre>
<p>anstatt:</p>
<pre><code class="language-rust">/// Kleines Beispiel.
# fn foo() {}
</code></pre>
<p>Man kann also <em>nur in Kommentaren</em> Zeilen mit einem <code>#</code> ausblenden.
Dieser Code wird dann mit kompiliert, aber nicht angezeigt.
Das kann man dazu nutzen um unvollständige Beispiele zu zeigen,
die allerdings trotzdem korrekt kompilieren sollen.
Zum Beispiel:</p>
<pre><code class="language-rust">let x = 5;
let y = 6;
println!(&quot;{}&quot;, x + y);
</code></pre>
<p>Dieser Code muss auf jeden Fall Zeile für Zeile erläutert werden.</p>
<p>Erst setzen wir <code>x</code> auf fünf:</p>
<pre><code class="language-rust">let x = 5;
# let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>
<p>Danach <code>y</code> auf sechs:</p>
<pre><code class="language-rust"># let x = 5;
let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>
<p>Zum Schluss geben wir deren Summe aus:</p>
<pre><code class="language-rust"># let x = 5;
# let y = 6;
println!(&quot;{}&quot;, x + y);
</code></pre>
<p>Hier das ganze nochmal als Plaintext:</p>
<blockquote>
<p>Erst setzen wir <code>x</code> auf fünf:</p>
<pre><code class="language-text">let x = 5;
# let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>
<p>Danach <code>y</code> auf sechs:</p>
<pre><code class="language-text"># let x = 5;
let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>
<p>Zum Schluss geben wir deren Summe aus:</p>
<pre><code class="language-text"># let x = 5;
# let y = 6;
println!(&quot;{}&quot;, x + y);
</code></pre>
</blockquote>
<h3>Macros kommentieren</h3>
<p>Hier ist ein Beispiel eines Dokumentierten <code>macro</code>s:</p>
<pre><code class="language-rust">/// Panic with a given message unless an expression evaluates to true.
///
/// # Examples
///
/// ```
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(1 + 1 == 2, “Math is broken.”);
/// # }
/// ```
///
/// ```should_panic
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(true == false, “I’m broken.”);
/// # }
/// ```
#[macro_export]
macro_rules! panic_unless {
    ($condition:expr, $($rest:expr),+) =&gt; ({ if ! $condition { panic!($($rest),+); } });
}
# fn main() {}
</code></pre>
<p>Hier fallen dir sicherlich drei Dinge auf:
wir müssen selber <code>extern crate</code> hinzufügen, damit wir <code>#[macro_use]</code> dranschreiben können.
Zweitens müssen wir auch noch selbst <code>main()</code> schreiben und zum Schluss ganz viele <code>#</code>s um das dann wieder unsichtbar zu machen.</p>
<h3>Dokumentation Testen</h3>
<p>Das geht entweder mit</p>
<pre><code class="language-bash">$ rustdoc --test path/to/my/crate/root.rs
</code></pre>
<p>oder</p>
<pre><code class="language-bash">$ cargo test
</code></pre>
<p><code>cargo test</code> funktioniert allerdings nur bei Bibliotheken, das liegt daran wie <code>rustdoc</code> funktioniert: Es linkt gegen die Bibliothek.</p>
<p>Annotationen die auch beim <a href="Testen.md">Testen</a> funktionieren, sind auch bei <code>rustdoc</code> manchmal nützlich, zum Beispiel:</p>
<pre><code class="language-rust">/// ```ignore
/// fn foo() {
/// ```
# fn foo() {}
</code></pre>
<p><code>ignore</code> bittet Rust dieses Beispiel bitte nicht mitzutesten,
wenn man weiß dass der Test scheitern würde.</p>
<pre><code class="language-rust">/// ```should_panic
/// assert!(false);
/// ```
# fn foo() {}
</code></pre>
<p>Das ist allerdings die allgemeinste Lösung, meisten ist eine der folgenden Möglichkeiten passender.
Oder man will lieber <code>text</code> verwenden, wenn es kein gar Rustcode ist oder Zeilen mit <code>#</code> ausblenden um ein Beispiel zu konstruieren welches trotzdem funktioniert.</p>
<p><code>should_panic</code> sagt <code>rustdoc</code> dass der code korrekt compiliert, aber der Test fehlschlagen soll.</p>
<pre><code class="language-rust">/// ```no_run
/// loop {
///     println!(&quot;Hello, world&quot;);
/// }
/// ```
# fn foo() {}
</code></pre>
<p>Und <code>no_run</code> führt dazu, dass dein Code kompiliert, aber nicht nicht ausgeführt  wird. Dann zählt der Test als bestanden, sobald er korrekt kompiliert hat.</p>
<h3>Module dokumentieren</h3>
<p>Rust hat noch eine weitere Art von Kommentar, <code>//!</code>.
Diese Syntax bezieht sich nicht auf den darauf folgenden Block,
sondern auf den äußeren.
Sprich:</p>
<pre><code class="language-rust">mod foo {
    //! This is documentation for the `foo` module.
    //!
    //! # Examples

    // ...
}
</code></pre>
<p>Am häufigsten wirst du <code>//!</code> am Anfang von Dateien sehen.
Dateien werden häufig also Module eingebunden: <code>./foo.rs</code> durch <code>mod foo</code>.</p>
<pre><code class="language-rust">//! A module for using `foo`s.
//!
//! The `foo` module contains a lot of useful functionality blah blah blah
</code></pre>
<p>Oder einfach am Anfang deiner <code>lib.rs</code>.</p>
<h3>Dokumentations Stil</h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505</a> (englisch) ist die vollständige Quelle für alle Konventionen bezüglich Dokumentation in Rust.</p>
<h2>Andere Dokumentation</h2>
<p>Alles oben genannte funktioniert auch in nicht-<code>.rs</code> Dateien.
Da Kommentare in Markdown geschrieben sind,
kannst du auch gleich <code>.md</code> Dateien verwenden.</p>
<p>Wenn du Dokumentation in Markdowndateien schreibst, brauchst du die Prefixe nicht mehr. Zum Beispiel:</p>
<pre><code class="language-rust">/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
</code></pre>
<p>ist einfach</p>
<pre><code class="language-markdown"># Examples

```
use std::rc::Rc;

let five = Rc::new(5);
```
</code></pre>
<p>in einer Markdown Datei. Wichtig ist hier nur, dass diese Dokumente immer einen Titel brauchen:</p>
<pre><code class="language-markdown">% The title

This is the example documentation.
</code></pre>
<p>Das <code>%</code> am Angang muss in der aller ersten Zeile sein.</p>
<h2>'doc' Attribute</h2>
<p>Wenn man genauer hinschaut, dann sind Kommentare nur eine einfachere Variante von Dokumentationsattributen:</p>
<pre><code class="language-rust">/// this
# fn foo() {}

#[doc=&quot;this&quot;]
# fn bar() {}
</code></pre>
<p>ist identisch zu:</p>
<pre><code class="language-rust">//! this

#![doc=&quot;/// this&quot;]
</code></pre>
<p>Das wirst du nicht häufig zu sehen bekommen, aber manchmal kann es nützlich sein.</p>
<h2>Re-Exporte</h2>
<p><code>rustdoc</code> wird die Dokumentation von Re-Exporten an an beiden Stellen einblenden:</p>
<pre><code class="language-ignore">extern crate foo;

pub use foo::bar;
</code></pre>
<p>Hier wird die Dokumentation für 'bar<code>sowohl in der Dokumentation für das Crate</code>foo`, also auch in der dokumentation deines Crates auftauchen.</p>
<p>Das kann durch <code>no_inline</code> unterdrückt werden:</p>
<pre><code class="language-ignore">extern crate foo;

#[doc(no_inline)]
pub use foo::bar;
</code></pre>
<h3>Kontrolle des HTML</h3>
<p>Auf ein paar Aspekte des von <code>rustdoc</code> generierten HTMLs kannst du mit <code>#![doc]</code> Einfluss nehmen.</p>
<pre><code class="language-rust">#![doc(html_logo_url = &quot;https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png&quot;,
       html_favicon_url = &quot;https://www.rust-lang.org/favicon.ico&quot;,
       html_root_url = &quot;https://doc.rust-lang.org/&quot;)]
</code></pre>
<p>Auf die weise kannst du das Logo, inklusive Favicon ersetzen.</p>
<h2>Optionen zum Einbinden von Dateien</h2>
<p><code>rustdoc</code> enthält außerdem noch ein paar weitere Kommandozeilen Optionen:</p>
<ul>
<li><code>--html-in-header FILE</code>: inkludiert den Inhalt der Datei am Ende der
<code>&lt;head&gt;...&lt;/head&gt;</code> Sektion.</li>
<li><code>--html-before-content FILE</code>: inkludiert den Inhalt einer Datei direkt nach
<code>&lt;body&gt;</code>, vor dem generierten Inhalt (inklusive Suchleiste).</li>
<li><code>--html-after-content FILE</code>: inkludiert den Inhalt der Datei am nach dem generierten Inhalt.</li>
</ul>
<h2>Sicherheitshinweis</h2>
<p>Das Markdown in den Dokumentationskommentaren wird unbearbeitet in die Webseite kopiert. Also vorsichtig mit HTML wie:</p>
<pre><code class="language-rust">/// &lt;script&gt;alert(document.cookie)&lt;/script&gt;
# fn foo() {}
</code></pre>
<p>☺</p>
<h1>Iteratoren</h1>
<p>Redern wir doch mal über Schleifen.</p>
<p>Erinnerst du dich noch an Rusts <code>for</code>-Schleifen?
Hier nochmal zur Erinnerung:</p>
<pre><code class="language-rust">for x in 0..10 {
    println!(&quot;{}&quot;, x);
}
</code></pre>
<p>Nun da du schon etwas mehr Rust kennst können wir ja mal etwas genauer darauf eingehen, wie das so funktioniert.
Ranges (wie <code>0..10</code>) sind &quot;Iteratoren&quot;.
Ein Iterator ist etwas auf dem man <code>.next()</code> aufrufen kann und das uns dann eine Sequenz an Dingen gibt.</p>
<p>So wie in diesem Beispiel:</p>
<pre><code class="language-rust">let mut range = 0..10;

loop {
    match range.next() {
        Some(x) =&gt; {
            println!(&quot;{}&quot;, x);
        },
        None =&gt; { break }
    }
}
</code></pre>
<p>Hier erstellen wir ein <strong><em>mutable binding</em></strong> zu einer Range.
Jetzt können wir mit <code>loop</code> darüber iterieren.
Das innere <code>match</code> entscheidet anhand der Ausgabe von <code>range.next()</code> ob wir weitermachen.
<code>.next()</code> gibt ein <code>Option&lt;i32&gt;</code> aus, also entweder ein <code>Some(i32)</code>, dann machen wir weiter, oder ein <code>None</code>, dann brechen wir mit <code>break</code> ab.</p>
<p><strong>Nein</strong>, dass musst du nicht jedes mal so machen, dafür gibt es <code>for</code>!</p>
<p><code>for</code> ist eigentlich nur syntaktischer Zucker für dieses <code>loop</code>/<code>match</code>/<code>break</code>-Konstrukt.
<code>for</code>-Schleifen sind allerdings nicht das einzige was Iteratoren benutzt.
Um seine eigenen Iteratoren verwenden zu können muss man das <code>Iterator</code> Trait implementieren.
Wie man das macht liegt etwas außerhalb des Rahmens dieses Kapitels.
Rust bietet eine ganze Reihe nützlicher Iterator für unterschiedliche Aufgaben.
Bevor wir allerdings auf diese genauer eingehen noch ein Anti-Pattern, welches du unbedingt vermeiden solltest. Und zwar solltest du eine Range nicht zum Zählen verwenden, zum Beispiel so:</p>
<pre><code class="language-rust">let nums = vec![1, 2, 3];

for i in 0..nums.len() {
    println!(&quot;{}&quot;, nums[i]);
}
</code></pre>
<p>Das ist zwar möglich, aber unnötig kompliziert, denn Vektoren bringen ihre eigenen Iteratoren mit:</p>
<pre><code class="language-rust">let nums = vec![1, 2, 3];

for num in &amp;nums {
    println!(&quot;{}&quot;, num);
}
</code></pre>
<p>Das ist besser aus zwei Gründen.
Ersten drückt das besser aus worum es hier geht, es ist semantisch sinnvoller.
Und zweitens ist es effizienter und sicherer,
die erste Variante muss extra checken ob die Indexe überhaupt valide sind.
Das ist allgemein der Vorteil von Iteratoren, sie sind auch ohne bound checks sicher.</p>
<p>Es gibt noch eine kleine Unklarheit aufgrund der Tatsache wie <code>println!</code> funktioniert.
<code>num</code> ist eigentlich ein <code>&amp;i32</code>, also nur eine Referenz auf ein <code>i32</code>.
<code>println!</code> übernimmt hier das Dereferenzieren für uns, wir sehen das also gar nicht.
Dementsprechend funktioniert auch dieser Code hier:</p>
<pre><code class="language-rust">let nums = vec![1, 2, 3];

for num in &amp;nums {
    println!(&quot;{}&quot;, *num);
}
</code></pre>
<p>Hier dereferenzieren wir <code>num</code> explizit.
Warum gibt uns <code>&amp;nums</code> Referenzen?
Erstens, weil wir explizit mit <code>&amp;</code> danach gefragt haben.
Zweitens, wenn es uns die Daten direkt geben würde müssten wir deren Besitzer werden, das heißt es müsste implizit kopieren.
Mit <code>&amp;</code> leihen wir nur Referenzen zu den Elementen aus, ohne kopieren oder verschieben zu müssen.</p>
<p>Nun da wir festgestellt haben, dass Ranges nicht das tun was wir wollen,
reden wir mal darüber was wir eigentlich wollen.</p>
<p>Es gibt drei Kategorien von Dingen die hier wichtig sind:
<strong>Iteratoren</strong>, <strong>Iterator-Adapter</strong> und <strong>Konsumenten</strong>.</p>
<ul>
<li><em>Iteratoren</em> geben uns eine Sequenz von Werten, einen nach dem anderen.</li>
<li><em>Iterator-Adapter</em> operieren auf Iteratoren und produzieren andere Iteratoren</li>
<li><em>Konsumenten</em> nehmen Iteratoren und produzieren daraus finale Werte oder Mengen.</li>
</ul>
<p>Reden wir als erstes mal über die Konsumenten, da wir ja schon einen Iterator gesehen haben, Ranges.</p>
<h2>Konsumenten</h2>
<p>Ein <em>Konsument</em> &quot;konsumiert&quot; einen Iterator, das heißt, dass er daraus eine feste  Menge Werte oder einen einzelnen Wert daraus erstellt.
Der gebräuchlichste Konsument ist <code>collect()</code>.
Dieser Code hier kompiliert nicht, zeigt aber die Verwendung von <code>collect()</code>:</p>
<pre><code class="language-rust,ignore">let one_to_one_hundred = (1..101).collect();
</code></pre>
<p>Wie du siehst rufen wir <code>collect()</code> auf unseren Iterator auf.
<code>collect()</code> nimmt so viele Elemente wie ein Iterator ihm gibt und gibt eine Sammlung an Resultaten aus.
Warum kompiliert dieser Code also nicht?
Rust kann hier nicht erkennen, welchen Type die Elemente von <code>(0..101)</code> haben.
Die Sammlung muss aber einen Bestimmten Typ haben, also geben wir hier einfach einen an:</p>
<pre><code class="language-rust">let one_to_one_hundred = (1..101).collect::&lt;Vec&lt;i32&gt;&gt;();
</code></pre>
<p>Falls du die <code>::&lt;&gt;</code> Syntax noch vor Augen hast, sie erlaubt es uns einen Hinweis auf den Typ zu geben, denn eigentlich ist <code>collect()</code> als <code>fn collect&lt;B: FromIterator&lt;Self::Item&gt;&gt;(self)</code> implementiert.
Mit <code>_</code> können wir einen partiellen tipp geben:</p>
<pre><code class="language-rust">let one_to_one_hundred = (1..101).collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
<p>Das sagt so viel wie &quot;Sammel in einen <code>Vec&lt;T&gt;</code>, aber inferiere bitte was <code>T</code> für mich.&quot;
<code>_</code> heißt deshalb manchmal auch &quot;Typeplatzhalter&quot;.</p>
<p>Neben <code>collect()</code> gibt es auch noch <code>find()</code>.</p>
<pre><code class="language-rust">let greater_than_forty_two = (0..100)
                             .find(|x| *x &gt; 42);

match greater_than_forty_two {
    Some(_) =&gt; println!(&quot;Found a match!&quot;),
    None =&gt; println!(&quot;No match found :(&quot;),
}
</code></pre>
<p><code>find()</code> nimmt eine Closure und gibt das erste Elemente zurück, für das die Closure <code>true</code> zurückgibt.
<code>find()</code> gibt ein <code>Option&lt;T&gt;</code> zurück, anstatt dem Element selbst, da es ja auch nichts, <code>None</code>, finden könnte.</p>
<p>Ein weiterer Konsument ist <code>fold()</code>:</p>
<pre><code class="language-rust">let sum = (1..4).fold(0, |sum, x| sum + x);
</code></pre>
<p><code>fold(basis, |akkumulator, element| ...)</code> nimmt zwei Argumente:
Das erste ist ein Element, genannt <em>Basis</em>.
Das zweite ist eine Closure, die selbst zwei Argumente annimmt: den <em>Akkumulator</em> und ein <em>Element</em>.
Bei jeder Iteration wird die Closure aufgerufen und das Resultat ist bei der nächsten Iteration der Akkumulator.
Beim erstenmal ist die Basis noch der Akkumulator.</p>
<p>Verwirrt? Schon klar.</p>
<p>Machen wir das mal an einem Beispiel etwas deutlicher:</p>
<p>| Basis | Akkumulator | Element | Closure Ergebnis |
|-------|-------------|---------|------------------|
| 0     | 0           | 1       | 1                |
| 0     | 1           | 2       | 3                |
| 0     | 3           | 3       | 6                |</p>
<pre><code class="language-rust"># (1..4)
.fold(0, |sum, x| sum + x);
</code></pre>
<p><code>0</code> ist unsere Basis hier, <code>sum</code> ist unser Akkumulator und <code>x</code> das Element.
Beim ersten Mal ist <code>sum</code> <code>0</code> und <code>x</code> ist <code>1</code>, das erste Element von <code>nums</code>.
Dann addieren wir <code>sum</code> und <code>x</code>, also <code>0 + 1 = 1</code>.
Das Ergebnis ist beim zweiten Mal ist dann der Akkumulator, also <code>sum</code> und das nächste Element, <code>2</code>, ist nun unser <code>x</code>.
<code>1 + 2 = 3</code>, und dann ist das wieder <code>sum</code>.
Im letzten Durchgang ist <code>x</code> nun <code>3</code>, also <code>3 + 3 = 6</code>, fertig.</p>
<p><code>fold()</code> sieht auf den ersten Blick etwas komisch aus, aber danach siehst du dass du es überall brauchen wirst, immer wenn du eine Liste an Dingen hast, die du zu einem einzigen Ergebnis zusammenfassen musst.</p>
<p>Konsumenten sind vor allem aufgrund einer Eigenschaft von Iteratoren wichtig, die wir noch gar nicht besprochen hatten, Iteratoren sind faul oder &quot;lazy&quot;.
Was bedeutet das? Das sehen wir gleich wenn wir über Iteratoren reden.</p>
<h2>Iteratoren</h2>
<p>Wie wir bereits festgestellt haben sind Iteratoren etwas auf dem wir wiederholt <code>.next()</code> aufrufen können und das uns dann eine Sequenz von Dingen gibt.
Weil du <code>.next()</code> aufrufen musst können sich Iteratoren die Arbeit sparen,
alle Elemente im Voraus zu generieren.
Dieser Code hier zum Beispiel generiert nicht wirklich die zahlen von <code>1</code> bis <code>99</code>, sondern repräsentiert nur Sequenz:</p>
<pre><code class="language-rust">let nums = 1..100;
</code></pre>
<p>Da wir mit der Range nicht wirklich irgendwas gemacht haben, hat es auch keine Sequenz generiert.
Wenn wir sie allerdings konsumieren:</p>
<pre><code class="language-rust">let nums = (1..100).collect::&lt;Vec&lt;i32&gt;&gt;();
</code></pre>
<p>dann verlangt <code>collect()</code> von unserer Range der Reihe nach jede Zahl und somit wird die Sequenz erst erzeugt.</p>
<p>Ranges sind einer von zwei grundlegenden Iteratoren wie wir kennen lernen werden.
Der andere ist <code>iter()</code>.
<code>iter()</code> macht aus einem <code>Vector</code> einen einfachen Iterator der uns jedes Element gibt:</p>
<pre><code class="language-rust">let nums = vec![1, 2, 3];

for num in nums.iter() {
   println!(&quot;{}&quot;, num);
}
</code></pre>
<p>Diese zwei Iteratoren sollten am Anfang reichen, es gibt aber noch fortgeschrittenere Iteratoren, inklusive unendlichen.</p>
<p>Das reicht aber erstmal. Iterator-Adapter sind das letzte Konzept dem wir uns hier widmen wollen. Also...</p>
<h2>Iterator-Adapter</h2>
<p><em>Iterator-Adapter</em> nehmen Iteratoren und modifizieren sie um daraus neue Iteratoren zu machen. Der einfachste ist <code>map</code>:</p>
<pre><code class="language-rust,ignore">(1..100).map(|x| x + 1);
</code></pre>
<p><code>map</code> ruft auf jedes Element eines Iterators eine Closure auf.
Das oben genannte Beispiel gibt uns also <code>2-100</code>.
Zumindest fast, wenn du das Beispiel kompilierst bekommst du eine Warnung:</p>
<pre><code class="language-text">warning: unused result which must be used: iterator adaptors are lazy and
         do nothing unless consumed, #[warn(unused_must_use)] on by default
(1..100).map(|x| x + 1);
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Hier schlägt die Faulheit zu!
Die Closure wird nie ausgeführt werden.
Genau wie im nächsten Beispiel, welches <strong>keine</strong> Zahlen ausgibt:</p>
<pre><code class="language-rust,ignore">(1..100).map(|x| println!(&quot;{}&quot;, x));
</code></pre>
<p>Wenn du einen Iterator mit Nebeneffekten verwenden willst, dann nimm lieber <code>for</code>.</p>
<p>Es gibt tonnenweise interessante Iterator-Adapter.
<code>take()</code> gibt einen Iterator über die nächsten 5 Elemente von dem original Iterator zurück.
Probieren wir das doch mal an einer unendlichen Range aus:</p>
<pre><code class="language-rust">for i in (1..).take(5) {
    println!(&quot;{}&quot;, i);
}
</code></pre>
<p>Hier bekommen wir:</p>
<pre><code class="language-text">1
2
3
4
5
</code></pre>
<p><code>filter()</code> ist ein Adapter der eine Closure nimmt, die <code>true</code> oder <code>false</code> zurück gibt.
Der neue Iterator enthält dann nur Element für die die Closure <code>true</code> zurück gegeben hat:</p>
<pre><code class="language-rust">for i in (1..100).filter(|&amp;x| x % 2 == 0) {
    println!(&quot;{}&quot;, i);
}
</code></pre>
<p>Hier kriegen wir alle geraden Zahlen zwischen 1 und hundert.
Wichtig: <code>filter()</code> konsumiert die Elemente nicht, es gibt nur Referenzen weiter, deshalb nimmt die Closure auch nur <code>&amp;x</code> an.</p>
<p>Du kannst alle drei Sachen hintereinander hängen, angefangen mit einem Iterator als &quot;Quelle&quot; ein paar Adaptern als &quot;Filter&quot; und einem Konsumenten zum Schluss:</p>
<pre><code class="language-rust">(1..)
    .filter(|&amp;x| x % 2 == 0)
    .filter(|&amp;x| x % 3 == 0)
    .take(5)
    .collect::&lt;Vec&lt;i32&gt;&gt;();
</code></pre>
<p>Das hier ergibt einen <code>Vector</code> der <code>6</code>, <code>12</code>, <code>18</code>, <code>24</code> und <code>30</code> enthält.</p>
<p>Das ist nur ein kleiner Vorgeschmack darauf was man mit Iteratoren, Iterator-Adaptern und Konsumenten alles tun kann.
Es gibt eine Menge richtig nützlicher Iteratoren und du kannst auch deine eigenen schreiben.
Iteratoren bieten eine sichere und effiziente Methode um all möglichen Listen zu manipulieren.
Am Anfang ist das vielleicht etwas ungewohnt, aber nach einer Weile will man gar nicht mehr zurück.
Eine vollständige Liste aller Iteratoren und Konsumenten lies die <a href="http://doc.rust-lang.org/stable/std/iter/index.html">Moduldokumentation</a> für Iterator.</p>
<h1>Nebenläufigkeit</h1>
<h1>Fehlerbehandlung</h1>
<h1>Garantien Wählen</h1>
<h1>FFI</h1>
<h1>Borrow und AsRef</h1>
<h1>Release Kanäle</h1>
<h1>Syntax und Semantik</h1>
<p>Dieser Abschnitt zerbricht Rust in kleine Stückchen,
eines für jedes Konzept.</p>
<p>Wenn du Rust lieber <em>bottom up</em> lernen möchtest,
dann lies ruhig in diesem Abschnitt weiter.</p>
<p>Dieser Abschnitt bildet außerdem eine Referenz für jedes Konzept.
Also wenn du ein anderes Tutorial liest und irgendwas verwirrend findest,
dann findest du das entsprechende Konzept hier irgendwo erklärt.</p>
<h1>Variablenbindung</h1>
<p>Fast jedes nicht-triviale Rust Programm verwendet <em>Variablenbindungen</em>.
Sie sehen so aus:</p>
<pre><code class="language-rust">fn main() {
    let x = 5;
}
</code></pre>
<p><code>fn main() {</code> in jedes Beispiel zu schreiben ist ein wenig mühsam,
also werden wir es in Zukunft weglassen. Falls du diese Beispiele ausprobierst,
stelle sicher, dass du deinen Code in einer <code>main()</code> Methode schreibst
(und nicht wie wir weglässt). Ansonsten bekommst du einen Fehler.</p>
<p>In vielen Sprachen wird das eine <em>Variable</em> genannt, aber Rusts
Variablenbindungen haben ein paar Tricks im Ärmel.
Zum Beispiel ist die linke Seite des <code>let</code> Anweisung ein ‘<a href="Muster.md">Muster</a>’
und nicht einfach nur ein Variablenname. Das bedeutet,
dass wir solche Sachen tun können:</p>
<pre><code class="language-rust">let (x, y) = (1, 2);
</code></pre>
<p>Nach dem ausführen dieser Anweisung ist <code>x</code> <code>1</code> und <code>y</code> wird <code>2</code> sein.
Muster sind wirklich mächtig und haben <a href="Muster.md">ihren eigenen Abschnitt</a>
im Buch. Wir brauchen diese Features fürs erste nicht, also behalten wir
uns das hier erstmal im Hinterkopf während wir weiter machen.</p>
<p>Rust ist eine statisch typisierte Sprache, was bedeutet, dass wir unsere
Typen im Voraus angeben müssen und diese zur Kompilierzeit überprüft werden.
Aber warum kompiliert dann unser erstes Beispiel? Nun, kann etwas namens
‘Typinferenz’. Wenn Rust den Typ alleine herausfinden kann, dann müssen
wir den Typ nicht unbedingt angeben.</p>
<p>Wir können den Typ aber angeben, wenn wir wollen.
Ein Typ kommt nach einem Doppelpunkt (<code>:</code>):</p>
<pre><code class="language-rust">let x: i32 = 5;
</code></pre>
<!--
Fehlende Übersetzung:
"If I asked you to read this out loud to the rest of the class, you’d say “`x`
is a binding with the type `i32` and the value `five`.”"
<p>Ich weis nicht genau wie das zu formulieren ist. ~~~ panicbit 02.10.15
--&gt;</p>
<p>In diesem Fall stellt <code>x</code> eine vorzeichenbehaftete 32-bit Ganzzahl dar.
Rust hat viele verschiedene primitive Ganzzahl Typen.
Sie beginnen mit <code>i</code> für vorzeichenbehaftete Ganzzahlen und
mit <code>u</code> für vorzeichenlose Ganzzahlen. Die möglichen Ganzzahlgrößen sind
8, 16, 32 und 64 Bits.</p>
<p>In zukünftigen Beispielen werden wir manchmal den Typ in einem Kommentar
angeben. Diese Beispiele werden so aussehen:</p>
<pre><code class="language-rust">fn main() {
    let x = 5; // x: i32
}
</code></pre>
<p>Beachte die Ähnlichkeit zwischen dieser Anmerkung und der Syntax,
die man mit <code>let</code> verwendet. Diese Art von Kommentar ist kein
idiomatisches Rust, aber wir werden sie dennoch gelegentlich verwenden
um klar zu machen, welche Typen Rust ableitet.</p>
<p>Standardmäßig sind Bindungen <em>immutable</em> [engl.: Unveränderbar].
Dieser code wird nicht kompilieren:</p>
<pre><code class="language-rust">let x = 5;
x = 10;
</code></pre>
<p>Er wird dir diesen Fehler geben:</p>
<pre><code class="language-text">error: re-assignment of immutable variable `x`
     x = 10;
     ^~~~~~~
</code></pre>
<p>Wenn du eine Bindung <em>mutable</em> [engl.: veränderbar] machen willst,
dann geht das mit <code>mut</code>.</p>
<pre><code class="language-rust">let mut x = 5; // mut x: i32
x = 10;
</code></pre>
<p>Es gibt verschiedene Gründ, dass Bindungen standardmäßig unveränderbar sind,
aber betrachten wir es einfach mal aus Sicht eines der Hauptziele von Rust:
Sicherheit. Wenn du vergisst <code>mut</code> zu schreiben, dann wird der Compiler
das abfangen und dich wissen lassen, dass du etwas veränderst,
was du vielleicht garnicht verändern willst.
Wären Bindungen standardmäßig veränderbar, dann könnte dir
der Compiler das nicht miteilen.
Wenn die Veränderung doch beabsichtigt ist,
dann ist die Lösung ziemlich einfach: Füge <code>mut</code> hinzu.</p>
<p>Es gibt noch weitere gute Gründe veränderbaren Zustand so viel wie möglich
zu vermeiden, aber das sprengt den Ramen dieses Guides.
Im Allgemeinen kann man häufig ausdrückliche Veränderungen vermeiden,
somit ist diese in Rust bevorzugt. Dennoch benötigt man manchmal
Veränderungen, also ist sie nicht verboten.</p>
<p>Also zurück zu Bindungen. Rusts Variablenbindungen haben noch einen weiteren
Aspekt der von anderen Sprachen abweicht:
Bindungen müssen initialisiert werden, bevor man sie benutzen kann.</p>
<p>Lass uns das ausprobieren.
Ändere deine <code>src/main.rs</code> damit sie so aussieht:</p>
<pre><code class="language-rust">fn main() {
    let x: i32;

    println!(&quot;Hallo Welt!&quot;);
}
</code></pre>
<p>Du kannst <code>cargo build</code> in der Kommandozeile verwenden um es zu kompilieren.
Du wirst zwar eine Warnung bekommen, aber das Programm wird trotzdem
&quot;Hallo Welt!&quot; ausgeben:</p>
<pre><code class="language-text">   Compiling hallo_welt v0.0.1 (file:///home/du/projekte/hallo_welt)
src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]
   on by default
src/main.rs:2     let x: i32;
                      ^
</code></pre>
<p>Rust warnt uns jedes mal, wenn eine Bindung nicht verwendet wird, ist
aber ansonsten kein Fehler an sich.
Die Sache ändert sich jedoch, wenn wir versuchen dieses <code>x</code> zu verwenden.
Lass uns das mal ausprobieren. Ändere dein Programm wie folgt:</p>
<pre><code class="language-rust">fn main() {
    let x: i32;

    println!(&quot;Der Wert von x ist: {}&quot;, x);
}
</code></pre>
<p>Und, wenn wir versuchen zu kompilieren, bekommen wir diesen Fehler:</p>
<pre><code class="language-bash">$ cargo build
   Compiling hallo_welt v0.0.1 (file:///home/du/projekte/hallo_welt)
src/main.rs:4:40: 4:41 error: use of possibly uninitialized variable: `x`
src/main.rs:4     println!(&quot;Der Wert von x ist: {}&quot;, x);
                                                     ^
note: in expansion of format_args!
&lt;std macros&gt;:2:23: 2:77 note: expansion site
&lt;std macros&gt;:1:1: 3:2 note: in expansion of println!
src/main.rs:4:5: 4:42 note: expansion site
error: aborting due to previous error
Could not compile `hallo_welt`.
</code></pre>
<p>Rust lässt uns keinen uninitialisierten Wert verwenden.
Lass uns als nächstes über die Sachen reden die wir in <code>println!</code>
verwendet haben.</p>
<p>Wenn du die zwei geschweiften Klammern (<code>{}</code>, manche nennen sie Schnurrbärte..)
in deinem auszugebenden String einfügst, dann interpretiert Rust sie als
Anweisung an dieser Stelle irgendeinen Wert einzufügen.
Wir fügen ein Komma und dann <code>x</code> hinzu um anzuzeigen, dass wir den Wert von
<code>x</code> an dieser Stelle stehen haben wollen. Das Komma wird benutzt um
mehrere Funktions- oder Makroargumente voneinander zu trenen, falls es mehr
als eines gibt.</p>
<p>Wenn du einfach nur die geschweiften Klammern verwendest, dann versucht
Rust den Wert, basierend auf dessen Typ, auf eine sinnvolle
Art und Weise darzustellen.
Wenn du das Format etwas genauer spezifizieren willst, stehen dir eine
[breite Palette an Optionen zur Verfügung][format].
Fürs erste bleiben wir beim Standard:
Es ist ja nicht so kompliziert eine Ganzzahl auszugeben.</p>
<h1>Funktionen</h1>
<p>Jedes Rust Programm hat mindestens eine Funktion,
die <code>main</code>:</p>
<pre><code class="language-rust">fn main() {
}
</code></pre>
<p>Das ist die simpelste Funktionsdeklaration. Wie wir zuvor schon erwähnt haben,
leitet <code>fn</code> eine Funktion ein. Darauf folgt der Name und
ein leeres paar Klammern, da diese Funktion keine Argumente hat,
und ein Paar geschweifte Klammern, die den Funktionskörper repräsentieren.
Hier ist eine Funktion namens <code>foo</code>:</p>
<pre><code class="language-rust">fn foo() {
}
</code></pre>
<p>Ok, wie funktioniert das nun mit Argumenten? Hier eine Funktion,
die eine Zahl ausgibt:</p>
<pre><code class="language-rust">fn print_number(x: i32) {
    println!(&quot;x is: {}&quot;, x);
}
</code></pre>
<p>Hier ist ein vollständiges Programm, welches <code>print_number</code> verwendet:</p>
<pre><code class="language-rust">fn main() {
    print_number(5);
}

fn print_number(x: i32) {
    println!(&quot;x is: {}&quot;, x);
}
</code></pre>
<p>Wie du sehen kannst funktionieren Funktionsargumente
ähnlich wie <code>let</code> Deklarationen:
Man fügt dem Namen einen Typ durch ein Doppelpunkt hinzu.</p>
<p>Hier ist ein vollständiges Programm,
welches zwei Zahlen addiert und dann ausgibt:</p>
<pre><code class="language-rust">fn main() {
    print_sum(5, 6);
}

fn print_sum(x: i32, y: i32) {
    println!(&quot;sum is: {}&quot;, x + y);
}
</code></pre>
<p>Wie du siehst werden Argumente durch ein Komma getrennt.
Das gilt sowohl für den Aufruf als auch für die Deklaration von Funktionen.</p>
<p>Anders als bei <code>let</code>, <strong>musst</strong> du die Typen von Funktionsargumenten angeben.
Das hier funktioniert nicht:</p>
<pre><code class="language-rust">fn print_sum(x, y) {
    println!(&quot;sum is: {}&quot;, x + y);
}
</code></pre>
<pre><code>
Man bekommt diesen Fehler:

```text
expected one of `!`, `:`, or `@`, found `)`
fn print_number(x, y) {
</code></pre>
<p>Das ist eine bewusste Designentscheidung.
Obwohl das herleiten der Typen eines kompletten Programmes möglich ist,
wie zum Beispiel in Sprachen wie Haskell, wird dennoch häufig dazu geraten
die Typen ausdrücklich zu dokumentieren.
Wir stimmen zu, dass ausdrückliche Typvermerke in Funktionssignaturen
und Typherleitung innerhalb von Funktionskörpern
wundervoller Mittelweg ist.</p>
<p>Wie gibt man einen Wert zurück?
Hier ist eine Funktion, die einen Wert inkrementiert.</p>
<pre><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>Rust Funktionen geben genau einen Wert zurück. Diesen gibt man nach einem
&quot;Pfeil&quot; an, welcher aus einem Bindestrich (<code>-</code>), gefolgt von einem
Größer-Gleich Zeichen (<code>&gt;</code>) besteht.
Die letzte Zeile der Funktion ist automatisch der Rückgabewert der Funktion.
Du wirst das hier das Semikolon fehlt. Wenn wir es hinzufügen:</p>
<pre><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>Würden wir einen Fehler bekommen:</p>
<pre><code class="language-text">error: not all control paths return a value
fn add_one(x: i32) -&gt; i32 {
     x + 1;
}

help: consider removing this semicolon:
     x + 1;
          ^
</code></pre>
<p>Dies offenbart zwei interessante Aspekte von Rust:
Rust ist eine ausdrucksorientierte Sprache [expression-based language].
Es gibt nur zwei Arten von Anweisungen, alles andere ist ein Ausdruck.</p>
<p>Also worin liegt der Unterschied? Ausdrücke geben einen Wert zurück,
Anweisungen nicht. Deswegen bekommen wir hier eine
‘not all control paths return a value’ Meldung:
Die Anweisung <code>x + 1;</code> gibt keinen Wert zurück.
Es gibt zwei Arten von Anweisungen in Rust:
<code>Deklarations-Anweisungen</code> und <code>Ausdrucks-Anweisungen</code>.
Alles andere ist ein Ausdruck.
Lass uns zuerst über <em>Deklarations-Anweisungen</em> sprechen.</p>
<p>In manchen Sprachen können Variablenbindungen auch als Ausdruck geschrieben
werden. Wie z.B. in Ruby:</p>
<pre><code class="language-ruby">x = y = 5
</code></pre>
<p>In Rust jedoch ist die Variablenbindung mit <code>let</code> <em>kein</em> Ausdruck.
Das Folgende erzeugt einen Fehler beim Kompilieren:</p>
<pre><code class="language-text">let x = (let y = 5); // expected identifier, found keyword `let`
</code></pre>
<p>Der Compiler sagt uns hier, dass er den Beginn eines Ausdrucks erwartet hat,
denn ein <code>let</code> kann nur eine Anweisung einleiten, aber keinen Ausdruck.</p>
<p>Beachte, dass eine Zuweisung an eine bereits gebundene Variable (z.B. <code>y = 5</code>)
trotzdem ein Ausdruck ist, auch wenn dieser nicht besonders nützlich ist.
Anders als in anderen Sprachen, wo der zugewiesene Wert zurückgegeben
werden würde, wird in Rust stattdessen das leere Tupel <code>()</code> zurückgegeben.
Der Grund dafür ist, dass der zugewiesene Wert <a href="Besitz.md">nur einen Besitzer</a>
haben kann und einen anderen Wert zurückzugeben wäre zu überraschend:</p>
<pre><code class="language-rust">let mut y = 5;

let x = (y = 6);  // x has the value `()`, not `6`
</code></pre>
<p>Die zweite Art von Anweisung in Rust ist die <em>Ausdrucks-Anweisung</em>.
Ihr Zweck ist es jeden Ausdruck in eine Anweisung zu verwandeln.
In praktischer Hinsicht erwartet Rusts Grammatik, dass Anweisungen
aufeinander folgen. Das bedeutet, dass man Semikolons nutzt um
Ausdrücke voneinander zu trennen. Das bedeutet auch,
dass Rust anderen Sprachen, welche auch ein Semikolon am ende einer Zeile
haben, sehr ähnlich sieht und man in Rust fast an jedem Ende einer Zeile ein
Semikolon sieht.</p>
<p>Wegen welcher Ausnahme sagen wir &quot;fast&quot;?.
Du hast sie bereits gesehen und zwar in diesem Code:</p>
<pre><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>Unsere Funktion gibt an ein <code>i32</code> zurückzugeben, aber mit einem Semikolon
würden wir stattdessen <code>()</code> zurückgeben.
Rust versteht, dass wir das wahrscheinlich nicht wollten und schlägt uns in
der Fehlermeldung, die wir sahen, vor das Semikolon zu entfernen.</p>
<h2>Frühzeitige Rückgabe</h2>
<p>Was ist mit frühzeitiger Rückgabe [early returns]?
Rust hat dafür ein Schlpsselwort namens <code>return</code>:</p>
<pre><code class="language-rust">fn foo(x: i32) -&gt; i32 {
    return x;

    // we never run this code!
    x + 1
}
</code></pre>
<p><code>return</code> in der letzten Zeile einer Funktion zu verwenden funktioniert zwar,
aber wird als schlechten Stil angesehen:</p>
<pre><code class="language-rust">fn foo(x: i32) -&gt; i32 {
    return x + 1;
}
</code></pre>
<p>Die vorherige Definition ohne <code>return</code> sieht vielleicht etwas komisch für dich
aus, falls du noch nicht mit Ausdrucksorientierten Sprachen gearbeitet hast,
aber du wirst dich mit der Zeit daran gewöhnen.</p>
<h2>Divergierende Funktionde</h2>
<p>Rust hat eine spzielle Syntax für sogennannte ‘divergierende Funktionen’
[diverging functions], also Funktionen, die niemals zurückkehren:</p>
<pre><code class="language-rust">fn diverges() -&gt; ! {
    panic!(&quot;This function never returns!&quot;);
}
</code></pre>
<p><code>panic!()</code> ist ein Makro, ähnlich wie <code>println!()</code>, was wir bereits kennen.
Anders jedoch als <code>println!()</code> sorgt <code>panic!()</code> dafür, dass der aktuelle
Thread mit einer Fehlermeldung abstürzt. Weil diese Funktion einen Crash hervorruft, kehrt sie niemals zurück, deswegen hat sie den Typ ‘<code>!</code>’,
was man als ‘divergiert’ liest.</p>
<p>Wenn du zu einer main Funktion einen <code>diverges()</code> Aufruf hinzufügst
und das Programm ausführst, dann sieht die Ausgabe in etwa so aus:</p>
<pre><code class="language-text">thread ‘&lt;main&gt;’ panicked at ‘This function never returns!’, hello.rs:2
</code></pre>
<p>Wenn du mehr Informationen haben willst, dann kannst du einen Backtrace durch
Setzen der <code>RUST_BACKTRACE</code> Umgebungsvariable erhalten:</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 ./diverges
thread '&lt;main&gt;' panicked at 'This function never returns!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</code></pre>
<p><code>RUST_BACKTRACE</code> funktioniert auch mit Cargos <code>run</code> Befehl:</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
     Running `target/debug/diverges`
thread '&lt;main&gt;' panicked at 'This function never returns!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</code></pre>
<p>Divergierende Funktionen passen mit jedem Typen zusammen:</p>
<pre><code class="language-rust">let x: i32 = diverges();
let x: String = diverges();
</code></pre>
<h2>Funktionszeiger</h2>
<p>Wir können auch eine Variablenbindung erzeugen, die auf eine Funktion zeigt:</p>
<pre><code class="language-rust">let f: fn(i32) -&gt; i32;
</code></pre>
<p><code>f</code> ist eine Variable, die auf eine Funktion zeigt, welche ein <code>i32</code> als
Argument entgegennimmt und ein <code>i32</code> zurückgibt. Zum Beispiel:</p>
<pre><code class="language-rust">fn plus_one(i: i32) -&gt; i32 {
    i + 1
}

// without type inference
let f: fn(i32) -&gt; i32 = plus_one;

// with type inference
let f = plus_one;
</code></pre>
<p>Wir können dann <code>f</code> benutzen um die Funktion aufzurufen:</p>
<pre><code class="language-rust">let six = f(5);
</code></pre>
<h1>Primitive Typen</h1>
<p>Die Rust Programmiersprache hat eine Reihe von Typen die als &quot;primitiv&quot;
angesehen werden. Das bedeutet, dass sie in die Sprache eingebaut sind.
Rust ist so strukturiert, dass die Standardbibliothek auch eine Menge
nützlicher Typen zur Verfügung stellt,
auch welche die auf primitiven Typen aufbauen, aber diese hier sind am
&quot;primitivsten&quot;.</p>
<h1>Booleans</h1>
<p>Rust hat einen boolschen Typ namens <code>bool</code>. Er hat zwei mögliche Werte,
<code>true</code> und <code>false</code>:</p>
<pre><code class="language-rust">let x = true;

let y: bool = false;
</code></pre>
<p>Eine übliche Nutzung ist in <a href="If.md"><code>if</code> Bedingungen</a>.</p>
<p>Du findest mehr Dokumentation zu <code>bool</code>s
<a href="https://doc.rust-lang.org/std/primitive.bool.html">in der Dokumentation der Standardbibliothek</a>.</p>
<h1><code>char</code></h1>
<p>Der <code>char</code> Typ stellt einen einzelnen Unicode Skalarwert dar.
Du kannst <code>char</code>s mit einzelnen Anführungsszeichen erzeugen: (<code>'</code>)</p>
<pre><code class="language-rust">let x = 'x';
let smiley = '😀';
</code></pre>
<p>Anders als in manch anderen Spachen bedeutet das, dass <code>char</code>s
kein einzelnes byte, sondern vier bytes sind.</p>
<p>Du findest mehr Dokumentation zu <code>char</code>s
<a href="https://doc.rust-lang.org/std/primitive.char.html">in der Dokumentation der Standardbibliothk</a>.</p>
<h1>Numerische Type</h1>
<p>Rust hat eine Vielzahl an numerischen Typen in ein paar Kategorien:
Vorzeichenbehaftet und Vorzeichenlos, feste und variable Größe,
Fließkomma- und Ganzzahl.</p>
<p>Diese Typen bestehen aus zwei Teilen: Der Kategorie und ihrer Größe.
Zum Beispiel ist <code>u16</code> ein vorzeichenloser Typ, der 16 bit groß ist.
Mehr bits erlauben größere Zahlen.</p>
<p>Wenn ein Zahlenliteral keinen Typ durch etwas zugewiesen bekommt, dann
sind das hier die Standards:</p>
<pre><code class="language-rust">let x = 42; // x hat den Typ i32

let y = 1.0; // y hat den Typ f64
</code></pre>
<p>Hier ist eine Liste der verschiedenen numerischen Typen, inklusive Links
zu ihrer jeweiligen Dokumentation in der Standardbibliothek:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.i8.html">i8</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i16.html">i16</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i32.html">i32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i64.html">i64</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u8.html">u8</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u16.html">u16</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u32.html">u32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u64.html">u64</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.isize.html">isize</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.usize.html">usize</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.f32.html">f32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.f64.html">f64</a></li>
</ul>
<p>Lass sie uns nach Kategorie durchgehen:</p>
<h2>Vorzeichenbehaftet und Vorzeichenlos</h2>
<p>Ganzzahlige Typen kommen in zwei Ausführungen daher:
Vorzeichenbehaftet und Vorzeichenlos. Lass uns eine 4-bit Zahl betrachten
um den Unterschied zu verstehen. Eine Vorzeichenbehaftete 4-bit Zahl würde
dir erlauben Zahlen von <code>-8</code> bis <code>+7</code> zu speichern. Vorzeichenbehaftete Zahlen
verwenden die Zweierkomplementdarstellung. Eine vorzeichenlose 4-bit Zahl
braucht keine negativen Zahlen speichern und kann deswegen Werte von
<code>0</code> bis <code>+15</code> annehmen.</p>
<p>Vorzeichenlose Typen nutzen ein <code>u</code> für ihre Kategorie,
und vorzeichenbehaftete Typen nutzen ein <code>i</code>.
Das <code>i</code> steht für &quot;integer&quot; (Ganzzahl).
Also ist <code>u8</code> eine vorzeichenlose 8-bit Ganzzahl und
<code>i8</code> ist eine vorzeichenbehaftete 8-bit Ganzzahl.</p>
<h2>Typen fester Größe</h2>
<p>Typen fester Größe enthalten eine speziefische Anzahl an Bits in
ihrer Darstellung. Gültige Bitgrößen sind <code>8</code>, <code>16</code>, <code>32 und</code>64<code>. Also ist</code>u32<code>eine vorzeichenlose Ganzzahl mit 32 Bits und</code>i64` eine vorzeichenbehaftete Ganzzahl mit 64 Bits.</p>
<h2>Fließkommatypen</h2>
<p>Rust besitzt auch zwei Fließkommatypen: <code>f32</code> und <code>f64</code>.
Diese entsprechen dem IEEE-754 Standard für Fließkommazahlen
einfacher und doppelter Genauigkeit.</p>
<h1>Arrays</h1>
<p>Wie die meisten Programmiersprachen hat Rust Listentypen
um Sequenzen von Dingen darzustellen.
Die grundlegenste ist das <em>Array</em>, eine Liste fester Größe von Elementen
des selben Typs. Standardmäßig sind Arrays <em>immutable</em>.</p>
<pre><code class="language-rust">let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // m: [i32; 3]
</code></pre>
<p>Arrays haben den Typ <code>[T; N]</code>. Wir werden über diese <code>T</code> Notation
<a href="Generics.md">im Generics Abschnitt</a> rede. Das <code>N</code> ist eine Konstante zur
Kompilierzeit um die Länge des Arrays anzuzeigen.</p>
<p>Es gibt eine abkürzende Schreibweise um jedes Element des Arrays mit dem
selben Wert zu initialisieren. In diesem Beispiel wird jedes Element von
<code>a</code> mit <code>0</code> initialisiert:</p>
<pre><code class="language-rust">let a = [0; 20]; // a: [i32; 20]
</code></pre>
<p>Du kannst die Anzahl der Elemente eines Array <code>a</code> via <code>a.len()</code> ermitteln:</p>
<pre><code class="language-rust">let a = [1, 2, 3];

println!(&quot;a hat {} Elemente&quot;, a.len());
</code></pre>
<p>Du kannst auf ein bestimmtes Element des Arrays
mithilfe eckiger Klammern (<code>[]</code>) zugreifen:</p>
<pre><code class="language-rust">let namen = [&quot;Graydon&quot;, &quot;Brian&quot;, &quot;Niko&quot;]; // namen: [&amp;str; 3]

println!(&quot;Der zweite Name ist: {}&quot;, namen[1]);
</code></pre>
<p>Die Indizes beginnen bei 0, wie in den meisten Programmiersprachen.
Somit ist der erste Name <code>namen[0]</code> und der zweite Name <code>namen[1]</code>.
Das vorherige Beispiel gibt <code>Der zweite Name ist: Brian</code> aus.
Wenn du versucht einen Index zu verwenden, der nicht im Array liegt,
dann wirst du einen Fehler bekommen: Arrayzugriffe werden zur Laufzeit
auf Gültigkeit geprüft. Solch ein fehlerhafter Zugriff ist die Quelle
vieler Bugs in anderen Systemsprachen.</p>
<p>Du findest mehr Dokumentation über <code>Arrays</code>s
<a href="https://doc.rust-lang.org/std/primitive.array.html">in der Dokumentation der Standardbibliothek</a>.</p>
<h1>Slices</h1>
<p>Ein <em>slice</em> [engl.: Scheibe/Stück] ist eine Referenz (oder eine &quot;Ansicht&quot;) auf
eine andere Datenstruktur. Sie erlauben einen sicheren und effizienten Zugriff
auf einen Teil eines Arrays ohne zu kopieren.
Zum Beispiel möchtest du vielleicht einfach nur auf eine Zeile einer
Datei im Speicher verweisen.
Aufgrund seiner Natur lässt sich ein <em>slice</em> nicht einfach so direkt erzeugen,
sondern nur aus einer existierenden Variable. Slices haben eine Länge,
können <em>mutable</em> oder <em>immutable</em> sein, und verhalten sich wie Arrays:</p>
<pre><code class="language-rust">let a = [0, 1, 2, 3, 4];
let middle = &amp;a[1..4]; // Ein Slice von a: Nur die Elemente 1, 2, und 3
let complete = &amp;a[..]; // Ein Slice mit allen Elementen von a
</code></pre>
<p>Slices haben den Typ <code>&amp;[T]</code>. Wir werden über dieses <code>T</code> sprechen, wenn wir
<a href="Generics.md">Generics</a> behandeln.</p>
<p>Du findest mehr Dokumentation über <code>Slice</code>s
<a href="https://doc.rust-lang.org/std/primitive.slice.html">in der Dokumentation der Standardbibliothek</a>.</p>
<h1><code>str</code></h1>
<p>Rusts <code>str</code> Typ ist der primitivste String Typ.
Als ein <a href="Gr%C3%B6%C3%9Fenlose_Typen.md">größenloser Typ</a> ist er alleine nicht sehr nützlich,
aber er wird sehr nützlich in Kombination mit einer Referenz, wie
zum Beispiel [<code>&amp;str</code>]<a href="Strings.md">strings</a>. Von daher belassen wir es dabei.</p>
<p>Du findest mehr Dokumentation über <code>str</code>s
<a href="https://doc.rust-lang.org/std/primitive.str.html">in der Dokumentation der Standardbibliothek</a>.</p>
<h1>Tupel</h1>
<p>Ein Tupel ist eine geordnete Liste fester Größe. Zum Beispiel:</p>
<pre><code class="language-rust">let x = (1, &quot;hallo&quot;);
</code></pre>
<p>Wie du sehen kannst sehen kannst, sieht der Typ eins Tupels genaus aus wie
das jeweilige Tupel, aber mit den jeweiligen Typen anstatt Werten.
Aufmerksame Leser werden auch feststellen, dass Tupel heterogen sind:
Wir haben ein <code>i32</code> und ein <code>&amp;str</code> in diesem Tupel.
(In Systemprogrammiersprachen sind Strings ein wenig Komplexer als in anderen
Sprachen. Fürs erste lies <code>&amp;str</code> als ein <em>string slice</em>.
Wir werden bald noch mehr darüber lernen.)</p>
<p>Tupel können einander zugewiesen werden, wenn die enthaltenen Typen und
die <a href="Gloassar.md#stelligkeit">Stelligkeit</a> identisch sind. Tupel haben die gleiche Stelligkeit,
wenn sie dieselbe Länge haben.</p>
<pre><code class="language-rust">let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;
</code></pre>
<p>Du kannst auf die Felder eines Tupels durch <em>let Destrukturierung</em> zugreifen.
Hier ist ein Beispiel:</p>
<pre><code class="language-rust">let (x, y, z) = (1, 2, 3);

println!(&quot;x ist {}&quot;, x);
</code></pre>
<p>Erinnerst du dich an <a href="Variablenbindung.md">zuvor</a>, als wir sagten, dass die linke Seite
etwas mächtiger ist als einfach nur eine Variablenbindung zuzuweisen?
Dabei sind wir nun. Wir können auf der linken Seite des <code>let</code> ein Muster
verwenden und, wenn es zu der rechten Seite passt, mehrere Variablenbindungen
gleichzeitig zuweisen. In diesem Fall &quot;destrukturiert&quot; <code>let</code> das Tupel bzw.
&quot;nimmt es auseinander&quot; und bindet die Teilstücke an Variablen.</p>
<p>Dieses Muster ist sehr mächtig und wir werden es später noch öfters sehen.</p>
<p>Du kannst ein Tupel mit einem einzelnen Element von einem Wert in Klammern durch
ein Komma unterscheiden:</p>
<pre><code class="language-rust">(0,); // Tupel mit einem Element
(0); // 0 in Klammern
</code></pre>
<h2>Tupel Indizierung</h2>
<p>Du kannst auf die Felder eines Tupel auch durch die &quot;Indizierungssyntax&quot;
zugreifen:</p>
<pre><code class="language-rust">let tupel = (1, 2, 3);

let x = tupel.0;
let y = tupel.1;
let z = tupel.2;

println!(&quot;x ist {}&quot;, x);
</code></pre>
<p>Wie auch bei der Array Indizierung wird bei 0 begonnen, aber anders als
bei der Array Indizierung verwendet man ein <code>.</code> anstatt <code>[]</code>.</p>
<p>Du findest mehr Dokumentation über Tupel
<a href="https://doc.rust-lang.org/std/primitive.tuple.html">in der Dokumentation der Standardbibliothek</a>.</p>
<h1>Funktionen</h1>
<p>Funktionen haben auch einen Typ! Er sieht so aus:</p>
<pre><code class="language-rust">fn foo(x: i32) -&gt; i32 { x }

let x: fn(i32) -&gt; i32 = foo;
</code></pre>
<p>In diesem Fall ist <code>x</code> ein ‘Funktionszeiger’ auf eine Funktion,
welche ein <code>i32</code> akzeptiert und ein <code>i32</code> zurückgibt.</p>
<h1>Kommentare</h1>
<p>Nun, da wir Funktionen kennen, ist es ein guter Zeitpunkt über Kommentare
zu lernen. Kommentare sind Notizen, die man anderen Programmierern hinterlässt
um Dinge über deinen Code zu erklären.
Der Compiler ignoriert sie größtenteils.</p>
<p>Rust hat zwei wesentliche Arten von Kommentaren:
<em>Zeilenkommentare</em> [<em>line comments</em>] und <em>Doku-Kommentare</em> [<em>doc comments</em>].</p>
<p>Hier ein Beispiel mit 4 Zeilenkommentaren:</p>
<pre><code class="language-rust">// Line comments are anything after ‘//’ and extend to the end of the line.

let x = 5; // this is also a line comment.

// If you have a long explanation for something, you can put line comments next
// to each other. Put a space between the // and your comment so that it’s
// more readable.
</code></pre>
<p>Die andere Art von Kommentar ist ein Doku-Kommentar.
Doku-Kommentare werden mit <code>///</code> anstatt <code>//</code> eingeleitet und
unterstützen darin das Markdown Format:</p>
<pre><code>/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, add_one(5));
/// # fn add_one(x: i32) -&gt; i32 {
/// #     x + 1
/// # }
/// ```
fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p>Es gibt noch eine weitere Kommentarform, nämlich <code>//!</code>,
um Dinge zu Dokumentieren in denen diese Kommentare enthalten sind
(z.B. in Crates, Modulen oder Funktionen) ansttat das zu kommentieren,
was auf ihnen folgt.
Üblicherweise wird diese Form von Kommentar am Anfang einer
Crate (lib.rs) oder eines Moduls (mod.rs) verwendet:</p>
<pre><code class="language-rust">//! # The Rust Standard Library
//!
//! The Rust Standard Library provides the essential runtime
//! functionality for building portable Rust software.
</code></pre>
<p>Wenn du Doku-Kommentare schreibst, dann ist es sehr hilfreich, wenn du
Beispiele angibst.
Du wirst feststellen, dass wir hier ein neues Makro verwendet haben:
<code>assert_eq!</code>. Dies vergleicht zwei Werte und <code>panic!</code>t wenn sie nicht
gleich sind. Das ist sehr hilfreich in der Dokumentation.
Es gibt ein weiteres Makro, nämlich <code>assert!</code>, welches <code>panic!</code>t,
wenn der übergebene Wert <code>false</code> ist.</p>
<p>Du kannst das [<code>rustdoc</code>]<a href="Dokumentation.md">documentation</a> Tool verwenden um eine HTML
Dokumentation aus diesen Doku-Kommentaren zu erstellen und außerdem
den Beispielcode als Tests laufen lassen!</p>
<h1>if</h1>
<h1>Schleifen</h1>
<h1>Besitz</h1>
<h1>Referenzen und Ausleihen</h1>
<h1>Lebzeiten</h1>
<h1>Veränderbarkeit</h1>
<h1>Structs</h1>
<h1>Enums</h1>
<h1>Match</h1>
<h1>Muster</h1>
<h1>Methodensyntax</h1>
<h1>Vektoren</h1>
<h1>Strings</h1>
<h1>Generics</h1>
<h1>Traits</h1>
<h1>Drop</h1>
<h1>if let</h1>
<h1>Trait Objekte</h1>
<h1>Closures</h1>
<h1>Universal Function Call Syntax</h1>
<h1>Crates und Module</h1>
<h1><code>const</code> und <code>static</code></h1>
<h1>Attribute</h1>
<h1><code>type</code> Aliase</h1>
<h1>Zwischen typen umwandeln</h1>
<h1>Assoziierte Typen</h1>
<h1>Größenlose Typen</h1>
<h1>Operatoren und Überladen</h1>
<h1>Deref Umwandlung</h1>
<h1>Makros</h1>
<h1>Raw Zeiger</h1>
<h1><code>unsafe</code></h1>
<h1>Nightly Rust</h1>
<h1>Compiler Plugins</h1>
<h1>Inline Assembly</h1>
<h1><code>no_stdlib</code></h1>
<h1>Intrinsics</h1>
<h1>Lang items</h1>
<h1>Fortgeschrittenes Linken</h1>
<h1>Benchmark Tests</h1>
<h1>Box Syntax und Muster</h1>
<h1>Slice Muster</h1>
<h1>Assoziierte Konstanten</h1>
<h1>Glossar</h1>
<h1>Akademische Forschung</h1>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
