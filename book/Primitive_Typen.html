<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="{% block description %}{% endblock %}">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../">

        <link rel="stylesheet" href="book.css">
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- Font Awesome -->
        <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">

        <!-- MathJax -->
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="http://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>
    </head>
    <body>
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = localStorage.getItem('theme');
            if (theme == null) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = localStorage.getItem('sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="Einf√ºhrung.html"><strong>1.</strong> Einf√ºhrung</a></li><li><a href="book/Erste_Schritte.html"><strong>2.</strong> Erste Schritte</a></li><li><ul class="section"><li><a href="book/Rust_Installieren.html"><strong>2.1.</strong> Rust installieren</a></li><li><a href="book/Hallo_Welt.html"><strong>2.2.</strong> Hallo Welt</a></li><li><a href="book/Hallo_Cargo.html"><strong>2.3.</strong> Hallo Cargo</a></li></ul></li><li><a href="book/Lerne_Rust.html"><strong>3.</strong> Lerne Rust</a></li><li><ul class="section"><li><a href="book/Ratespiel.html"><strong>3.1.</strong> Ratespiel</a></li><li><a href="book/Speisende_Philosophen.html"><strong>3.2.</strong> Speisende Philosophen</a></li><li><a href="book/Rust_In_Anderen_Sprachen.html"><strong>3.3.</strong> Rust in anderen Sprachen</a></li></ul></li><li><a href="book/Effektives_Rust.html"><strong>4.</strong> Effektives Rust</a></li><li><ul class="section"><li><a href="book/Der_Stack_Und_Der_Heap.html"><strong>4.1.</strong> Der Stack und der Heap</a></li><li><a href="book/Testen.html"><strong>4.2.</strong> Testen</a></li><li><a href="book/Bedingte_Kompilierung.html"><strong>4.3.</strong> Bedingte Kompilierung</a></li><li><a href="book/Dokumentation.html"><strong>4.4.</strong> Dokumentation</a></li><li><a href="book/Iteratoren.html"><strong>4.5.</strong> Iteratoren</a></li><li><a href="book/Nebenl√§ufigkeit.html"><strong>4.6.</strong> Nebenl√§ufigkeit</a></li><li><a href="book/Fehlerbehandlung.html"><strong>4.7.</strong> Fehlerbehandlung</a></li><li><a href="book/Garantien_W√§hlen.html"><strong>4.8.</strong> Garantien W√§hlen</a></li><li><a href="book/FFI.html"><strong>4.9.</strong> FFI</a></li><li><a href="book/Borrow_Und_AsRef.html"><strong>4.10.</strong> Borrow und AsRef</a></li><li><a href="book/Release_Kan√§le.html"><strong>4.11.</strong> Release Kan√§le</a></li></ul></li><li><a href="book/Syntax_Und_Semantik.html"><strong>5.</strong> Syntax und Semantik</a></li><li><ul class="section"><li><a href="book/Variablenbindung.html"><strong>5.1.</strong> Variablenbindung</a></li><li><a href="book/Funktionen.html"><strong>5.2.</strong> Funktionen</a></li><li><a href="book/Primitive_Typen.html" class="active"><strong>5.3.</strong> Primitive Typen</a></li><li><a href="book/Kommentare.html"><strong>5.4.</strong> Kommentare</a></li><li><a href="book/If.html"><strong>5.5.</strong> if</a></li><li><a href="book/Schleifen.html"><strong>5.6.</strong> Schleifen</a></li><li><a href="book/Besitz.html"><strong>5.7.</strong> Besitz</a></li><li><a href="book/Referenzen_Und_Ausleihen.html"><strong>5.8.</strong> Referenzen und Ausleihen</a></li><li><a href="book/Lebzeiten.html"><strong>5.9.</strong> Lebzeiten</a></li><li><a href="book/Ver√§nderbarkeit.html"><strong>5.10.</strong> Ver√§nderbarkeit</a></li><li><a href="book/Structs.html"><strong>5.11.</strong> Structs</a></li><li><a href="book/Enums.html"><strong>5.12.</strong> Enums</a></li><li><a href="book/Match.html"><strong>5.13.</strong> Match</a></li><li><a href="book/Muster.html"><strong>5.14.</strong> Muster</a></li><li><a href="book/Methodensyntax.html"><strong>5.15.</strong> Methodensyntax</a></li><li><a href="book/Vektoren.html"><strong>5.16.</strong> Vektoren</a></li><li><a href="book/Strings.html"><strong>5.17.</strong> Strings</a></li><li><a href="book/Generics.html"><strong>5.18.</strong> Generics</a></li><li><a href="book/Traits.html"><strong>5.19.</strong> Traits</a></li><li><a href="book/Drop.html"><strong>5.20.</strong> Drop</a></li><li><a href="book/If_Let.html"><strong>5.21.</strong> if let</a></li><li><a href="book/Trait_Objekte.html"><strong>5.22.</strong> Trait Objekte</a></li><li><a href="book/Closures.html"><strong>5.23.</strong> Closures</a></li><li><a href="book/UFCS.html"><strong>5.24.</strong> Universal Function Call Syntax</a></li><li><a href="book/Crates_Und_Module.html"><strong>5.25.</strong> Crates und Module</a></li><li><a href="book/Const_Und_Static.html"><strong>5.26.</strong> `const` und `static`</a></li><li><a href="book/Attribute.html"><strong>5.27.</strong> Attribute</a></li><li><a href="book/Type_Aliase.html"><strong>5.28.</strong> `type` Aliase</a></li><li><a href="book/Zwischen_Typen_Umwandeln.html"><strong>5.29.</strong> Zwischen typen umwandeln</a></li><li><a href="book/Assoziierte_Typen.html"><strong>5.30.</strong> Assoziierte Typen</a></li><li><a href="book/Gr√∂√üenlose_Typen.html"><strong>5.31.</strong> Gr√∂√üenlose Typen</a></li><li><a href="book/Operatoren_Und_√úberladen.html"><strong>5.32.</strong> Operatoren und √úberladen</a></li><li><a href="book/Deref_Umwandlung.html"><strong>5.33.</strong> Deref Umwandlung</a></li><li><a href="book/Makros.html"><strong>5.34.</strong> Makros</a></li><li><a href="book/Raw_Zeiger.html"><strong>5.35.</strong> Raw Zeiger</a></li><li><a href="book/Unsafe.html"><strong>5.36.</strong> `unsafe`</a></li></ul></li><li><a href="book/Nightly_Rust.html"><strong>6.</strong> Nightly Rust</a></li><li><ul class="section"><li><a href="book/Compiler_Plugins.html"><strong>6.1.</strong> Compiler Plugins</a></li><li><a href="book/Inline_Assembly.html"><strong>6.2.</strong> Inline Assembly</a></li><li><a href="book/No_Stdlib.html"><strong>6.3.</strong> `no_stdlib`</a></li><li><a href="book/Intrinsics.html"><strong>6.4.</strong> Intrinsics</a></li><li><a href="book/Lang_Items.html"><strong>6.5.</strong> Lang items</a></li><li><a href="book/Fortgeschrittenes_Linken.html"><strong>6.6.</strong> Fortgeschrittenes Linken</a></li><li><a href="book/Benchmark_Tests.html"><strong>6.7.</strong> Benchmark Tests</a></li><li><a href="book/Box_Syntax_Und_Muster.html"><strong>6.8.</strong> Box Syntax und Muster</a></li><li><a href="book/Slice_Muster.html"><strong>6.9.</strong> Slice Muster</a></li><li><a href="book/Assoziierte_Konstanten.html"><strong>6.10.</strong> Assoziierte Konstanten</a></li></ul></li><li><a href="book/Glossar.html"><strong>7.</strong> Glossar</a></li><li><a href="book/Akademische_Forschung.html"><strong>8.</strong> Akademische Forschung</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush"></i>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <i id="print-button" class="fa fa-print" title="Print this book"></i>
                    </div>
                </div>

                <div id="content" class="content">
                    <h1>Primitive Typen</h1>
<p>Die Rust Programmiersprache hat eine Reihe von Typen die als &quot;primitiv&quot;
angesehen werden. Das bedeutet, dass sie in die Sprache eingebaut sind.
Rust ist so strukturiert, dass die Standardbibliothek auch eine Menge
n√ºtzlicher Typen zur Verf√ºgung stellt,
auch welche die auf primitiven Typen aufbauen, aber diese hier sind am
&quot;primitivsten&quot;.</p>
<h1>Booleans</h1>
<p>Rust hat einen boolschen Typ namens <code>bool</code>. Er hat zwei m√∂gliche Werte,
<code>true</code> und <code>false</code>:</p>
<pre><code class="language-rust">let x = true;

let y: bool = false;
</code></pre>
<p>Eine √ºbliche Nutzung ist in <a href="If.md"><code>if</code> Bedingungen</a>.</p>
<p>Du findest mehr Dokumentation zu <code>bool</code>s
<a href="https://doc.rust-lang.org/std/primitive.bool.html">in der Dokumentation der Standardbibliothek</a>.</p>
<h1><code>char</code></h1>
<p>Der <code>char</code> Typ stellt einen einzelnen Unicode Skalarwert dar.
Du kannst <code>char</code>s mit einzelnen Anf√ºhrungsszeichen erzeugen: (<code>'</code>)</p>
<pre><code class="language-rust">let x = 'x';
let smiley = 'üòÄ';
</code></pre>
<p>Anders als in manch anderen Spachen bedeutet das, dass <code>char</code>s
kein einzelnes byte, sondern vier bytes sind.</p>
<p>Du findest mehr Dokumentation zu <code>char</code>s
<a href="https://doc.rust-lang.org/std/primitive.char.html">in der Dokumentation der Standardbibliothk</a>.</p>
<h1>Numerische Type</h1>
<p>Rust hat eine Vielzahl an numerischen Typen in ein paar Kategorien:
Vorzeichenbehaftet und Vorzeichenlos, feste und variable Gr√∂√üe,
Flie√ükomma- und Ganzzahl.</p>
<p>Diese Typen bestehen aus zwei Teilen: Der Kategorie und ihrer Gr√∂√üe.
Zum Beispiel ist <code>u16</code> ein vorzeichenloser Typ, der 16 bit gro√ü ist.
Mehr bits erlauben gr√∂√üere Zahlen.</p>
<p>Wenn ein Zahlenliteral keinen Typ durch etwas zugewiesen bekommt, dann
sind das hier die Standards:</p>
<pre><code class="language-rust">let x = 42; // x hat den Typ i32

let y = 1.0; // y hat den Typ f64
</code></pre>
<p>Hier ist eine Liste der verschiedenen numerischen Typen, inklusive Links
zu ihrer jeweiligen Dokumentation in der Standardbibliothek:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.i8.html">i8</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i16.html">i16</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i32.html">i32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.i64.html">i64</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u8.html">u8</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u16.html">u16</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u32.html">u32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.u64.html">u64</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.isize.html">isize</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.usize.html">usize</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.f32.html">f32</a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.f64.html">f64</a></li>
</ul>
<p>Lass sie uns nach Kategorie durchgehen:</p>
<h2>Vorzeichenbehaftet und Vorzeichenlos</h2>
<p>Ganzzahlige Typen kommen in zwei Ausf√ºhrungen daher:
Vorzeichenbehaftet und Vorzeichenlos. Lass uns eine 4-bit Zahl betrachten
um den Unterschied zu verstehen. Eine Vorzeichenbehaftete 4-bit Zahl w√ºrde
dir erlauben Zahlen von <code>-8</code> bis <code>+7</code> zu speichern. Vorzeichenbehaftete Zahlen
verwenden die Zweierkomplementdarstellung. Eine vorzeichenlose 4-bit Zahl
braucht keine negativen Zahlen speichern und kann deswegen Werte von
<code>0</code> bis <code>+15</code> annehmen.</p>
<p>Vorzeichenlose Typen nutzen ein <code>u</code> f√ºr ihre Kategorie,
und vorzeichenbehaftete Typen nutzen ein <code>i</code>.
Das <code>i</code> steht f√ºr &quot;integer&quot; (Ganzzahl).
Also ist <code>u8</code> eine vorzeichenlose 8-bit Ganzzahl und
<code>i8</code> ist eine vorzeichenbehaftete 8-bit Ganzzahl.</p>
<h2>Typen fester Gr√∂√üe</h2>
<p>Typen fester Gr√∂√üe enthalten eine speziefische Anzahl an Bits in
ihrer Darstellung. G√ºltige Bitgr√∂√üen sind <code>8</code>, <code>16</code>, <code>32 und</code>64<code>. Also ist</code>u32<code>eine vorzeichenlose Ganzzahl mit 32 Bits und</code>i64` eine vorzeichenbehaftete Ganzzahl mit 64 Bits.</p>
<h2>Flie√ükommatypen</h2>
<p>Rust besitzt auch zwei Flie√ükommatypen: <code>f32</code> und <code>f64</code>.
Diese entsprechen dem IEEE-754 Standard f√ºr Flie√ükommazahlen
einfacher und doppelter Genauigkeit.</p>
<h1>Arrays</h1>
<p>Wie die meisten Programmiersprachen hat Rust Listentypen
um Sequenzen von Dingen darzustellen.
Die grundlegenste ist das <em>Array</em>, eine Liste fester Gr√∂√üe von Elementen
des selben Typs. Standardm√§√üig sind Arrays <em>immutable</em>.</p>
<pre><code class="language-rust">let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // m: [i32; 3]
</code></pre>
<p>Arrays haben den Typ <code>[T; N]</code>. Wir werden √ºber diese <code>T</code> Notation
<a href="Generics.md">im Generics Abschnitt</a> rede. Das <code>N</code> ist eine Konstante zur
Kompilierzeit um die L√§nge des Arrays anzuzeigen.</p>
<p>Es gibt eine abk√ºrzende Schreibweise um jedes Element des Arrays mit dem
selben Wert zu initialisieren. In diesem Beispiel wird jedes Element von
<code>a</code> mit <code>0</code> initialisiert:</p>
<pre><code class="language-rust">let a = [0; 20]; // a: [i32; 20]
</code></pre>
<p>Du kannst die Anzahl der Elemente eines Array <code>a</code> via <code>a.len()</code> ermitteln:</p>
<pre><code class="language-rust">let a = [1, 2, 3];

println!(&quot;a hat {} Elemente&quot;, a.len());
</code></pre>
<p>Du kannst auf ein bestimmtes Element des Arrays
mithilfe eckiger Klammern (<code>[]</code>) zugreifen:</p>
<pre><code class="language-rust">let namen = [&quot;Graydon&quot;, &quot;Brian&quot;, &quot;Niko&quot;]; // namen: [&amp;str; 3]

println!(&quot;Der zweite Name ist: {}&quot;, namen[1]);
</code></pre>
<p>Die Indizes beginnen bei 0, wie in den meisten Programmiersprachen.
Somit ist der erste Name <code>namen[0]</code> und der zweite Name <code>namen[1]</code>.
Das vorherige Beispiel gibt <code>Der zweite Name ist: Brian</code> aus.
Wenn du versucht einen Index zu verwenden, der nicht im Array liegt,
dann wirst du einen Fehler bekommen: Arrayzugriffe werden zur Laufzeit
auf G√ºltigkeit gepr√ºft. Solch ein fehlerhafter Zugriff ist die Quelle
vieler Bugs in anderen Systemsprachen.</p>
<p>Du findest mehr Dokumentation √ºber <code>Arrays</code>s
<a href="https://doc.rust-lang.org/std/primitive.array.html">in der Dokumentation der Standardbibliothek</a>.</p>
<h1>Slices</h1>
<p>Ein <em>slice</em> [engl.: Scheibe/St√ºck] ist eine Referenz (oder eine &quot;Ansicht&quot;) auf
eine andere Datenstruktur. Sie erlauben einen sicheren und effizienten Zugriff
auf einen Teil eines Arrays ohne zu kopieren.
Zum Beispiel m√∂chtest du vielleicht einfach nur auf eine Zeile einer
Datei im Speicher verweisen.
Aufgrund seiner Natur l√§sst sich ein <em>slice</em> nicht einfach so direkt erzeugen,
sondern nur aus einer existierenden Variable. Slices haben eine L√§nge,
k√∂nnen <em>mutable</em> oder <em>immutable</em> sein, und verhalten sich wie Arrays:</p>
<pre><code class="language-rust">let a = [0, 1, 2, 3, 4];
let middle = &amp;a[1..4]; // Ein Slice von a: Nur die Elemente 1, 2, und 3
let complete = &amp;a[..]; // Ein Slice mit allen Elementen von a
</code></pre>
<p>Slices haben den Typ <code>&amp;[T]</code>. Wir werden √ºber dieses <code>T</code> sprechen, wenn wir
<a href="Generics.md">Generics</a> behandeln.</p>
<p>Du findest mehr Dokumentation √ºber <code>Slice</code>s
<a href="https://doc.rust-lang.org/std/primitive.slice.html">in der Dokumentation der Standardbibliothek</a>.</p>
<h1><code>str</code></h1>
<p>Rusts <code>str</code> Typ ist der primitivste String Typ.
Als ein <a href="Gr%C3%B6%C3%9Fenlose_Typen.md">gr√∂√üenloser Typ</a> ist er alleine nicht sehr n√ºtzlich,
aber er wird sehr n√ºtzlich in Kombination mit einer Referenz, wie
zum Beispiel [<code>&amp;str</code>]<a href="Strings.md">strings</a>. Von daher belassen wir es dabei.</p>
<p>Du findest mehr Dokumentation √ºber <code>str</code>s
<a href="https://doc.rust-lang.org/std/primitive.str.html">in der Dokumentation der Standardbibliothek</a>.</p>
<h1>Tupel</h1>
<p>Ein Tupel ist eine geordnete Liste fester Gr√∂√üe. Zum Beispiel:</p>
<pre><code class="language-rust">let x = (1, &quot;hallo&quot;);
</code></pre>
<p>Wie du sehen kannst sehen kannst, sieht der Typ eins Tupels genaus aus wie
das jeweilige Tupel, aber mit den jeweiligen Typen anstatt Werten.
Aufmerksame Leser werden auch feststellen, dass Tupel heterogen sind:
Wir haben ein <code>i32</code> und ein <code>&amp;str</code> in diesem Tupel.
(In Systemprogrammiersprachen sind Strings ein wenig Komplexer als in anderen
Sprachen. F√ºrs erste lies <code>&amp;str</code> als ein <em>string slice</em>.
Wir werden bald noch mehr dar√ºber lernen.)</p>
<p>Tupel k√∂nnen einander zugewiesen werden, wenn die enthaltenen Typen und
die <a href="Gloassar.md#stelligkeit">Stelligkeit</a> identisch sind. Tupel haben die gleiche Stelligkeit,
wenn sie dieselbe L√§nge haben.</p>
<pre><code class="language-rust">let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;
</code></pre>
<p>Du kannst auf die Felder eines Tupels durch <em>let Destrukturierung</em> zugreifen.
Hier ist ein Beispiel:</p>
<pre><code class="language-rust">let (x, y, z) = (1, 2, 3);

println!(&quot;x ist {}&quot;, x);
</code></pre>
<p>Erinnerst du dich an <a href="Variablenbindung.md">zuvor</a>, als wir sagten, dass die linke Seite
etwas m√§chtiger ist als einfach nur eine Variablenbindung zuzuweisen?
Dabei sind wir nun. Wir k√∂nnen auf der linken Seite des <code>let</code> ein Muster
verwenden und, wenn es zu der rechten Seite passt, mehrere Variablenbindungen
gleichzeitig zuweisen. In diesem Fall &quot;destrukturiert&quot; <code>let</code> das Tupel bzw.
&quot;nimmt es auseinander&quot; und bindet die Teilst√ºcke an Variablen.</p>
<p>Dieses Muster ist sehr m√§chtig und wir werden es sp√§ter noch √∂fters sehen.</p>
<p>Du kannst ein Tupel mit einem einzelnen Element von einem Wert in Klammern durch
ein Komma unterscheiden:</p>
<pre><code class="language-rust">(0,); // Tupel mit einem Element
(0); // 0 in Klammern
</code></pre>
<h2>Tupel Indizierung</h2>
<p>Du kannst auf die Felder eines Tupel auch durch die &quot;Indizierungssyntax&quot;
zugreifen:</p>
<pre><code class="language-rust">let tupel = (1, 2, 3);

let x = tupel.0;
let y = tupel.1;
let z = tupel.2;

println!(&quot;x ist {}&quot;, x);
</code></pre>
<p>Wie auch bei der Array Indizierung wird bei 0 begonnen, aber anders als
bei der Array Indizierung verwendet man ein <code>.</code> anstatt <code>[]</code>.</p>
<p>Du findest mehr Dokumentation √ºber Tupel
<a href="https://doc.rust-lang.org/std/primitive.tuple.html">in der Dokumentation der Standardbibliothek</a>.</p>
<h1>Funktionen</h1>
<p>Funktionen haben auch einen Typ! Er sieht so aus:</p>
<pre><code class="language-rust">fn foo(x: i32) -&gt; i32 { x }

let x: fn(i32) -&gt; i32 = foo;
</code></pre>
<p>In diesem Fall ist <code>x</code> ein ‚ÄòFunktionszeiger‚Äô auf eine Funktion,
welche ein <code>i32</code> akzeptiert und ein <code>i32</code> zur√ºckgibt.</p>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a href="book/Funktionen.html" class="mobile-nav-chapters previous">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="book/Kommentare.html" class="mobile-nav-chapters next">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="book/Funktionen.html" class="nav-chapters previous">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="book/Kommentare.html" class="nav-chapters next">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <script src="highlight.js"></script>
        <script src="book.js"></script>
    </body>
</html>
